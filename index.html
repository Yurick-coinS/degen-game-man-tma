<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>DEGEN-MAN: Solana Edition</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    :root {
      --board-size: 94vw;
      --max-board: 420px;
      --neon: #9945FF;
      --neon-glow: 0 0 16px #9945FF, 0 0 32px #9945FF;
      --neon-green: #14F195;
      --neon-green-glow: 0 0 8px #14F195, 0 0 16px #14F195;
    }

    body {
      margin: 0;
      padding: 0;
      background: #0f0f1a;
      color: #fff;
      font-family: 'Share Tech Mono', 'Courier New', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow-x: hidden;
      touch-action: none;
    }

    .console-header {
      width: 100vw;
      max-width: 420px;
      margin: 0 auto;
      margin-top: 12px;
      margin-bottom: 0;
      text-align: center;
      z-index: 10;
      position: relative;
      pointer-events: none;
    }

    .console-title {
      color: var(--neon);
      font-size: 2.1rem;
      font-family: 'Share Tech Mono', monospace;
      text-shadow: var(--neon-glow);
      font-weight: bold;
      margin-bottom: 0.2em;
      letter-spacing: 2px;
    }

    .collection-profile {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 7px;
      background: none;
      box-shadow: none;
      border-radius: 0;
      padding: 0 0 2px 0;
      margin: 0 auto 0 auto;
      min-height: 28px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1.08em;
      color: #FFD700;
      letter-spacing: 1px;
      user-select: none;
    }

    .collection-profile .candle-icon {
      display: inline-block;
      width: 18px;
      height: 18px;
      margin: 0 2px;
      border-radius: 50%;
      border: 2px solid #fff;
      vertical-align: middle;
      opacity: 0.4;
      filter: grayscale(1);
      transition: opacity 0.2s, filter 0.2s, border 0.2s;
      box-shadow: 0 0 6px #222;
    }

    .collection-profile .candle-icon.collected {
      opacity: 1;
      filter: none;
      border: 2px solid #14F195;
      box-shadow: 0 0 12px #14F195, 0 0 4px #FFD700;
    }

    .collection-profile .collection-label {
      margin-right: 8px;
      color: #FFD700;
      font-weight: bold;
      font-size: 1em;
      text-shadow: 0 0 6px #9945FF, 0 0 2px #fff;
      letter-spacing: 1px;
    }

    @media (max-width: 500px) {
      .collection-profile .candle-icon {
        width: 13px;
        height: 13px;
      }

      .collection-profile {
        font-size: 0.98em;
        min-height: 20px;
      }
    }

    .console-status {
      color: var(--neon-green);
      font-size: 1.1rem;
      text-shadow: var(--neon-green-glow);
      margin-bottom: 0.5em;
      letter-spacing: 1px;
    }

    .console-quest {
      margin: 8px 0;
      color: #FFD700;
      font-size: 1.1em;
      text-align: center;
    }

    #new-quest-btn {
      margin-bottom: 10px;
      display: none;
      background: #9945FF;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 5px 10px;
      font-family: 'Share Tech Mono', monospace;
      cursor: pointer;
    }

    #new-quest-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }

    .fomo-popup {
      position: absolute;
      top: 0.5em;
      left: 50%;
      transform: translateX(-50%);
      width: 94vw;
      max-width: var(--max-board);
      min-height: 44px;
      background: linear-gradient(90deg, #9945FF 70%, #14F195 100%);
      color: #fff;
      font-size: 1.08em;
      font-family: 'Share Tech Mono', monospace;
      font-weight: bold;
      letter-spacing: 1px;
      border-radius: 10px;
      box-shadow: 0 4px 24px #9945FF88, 0 1px 8px #14F19544;
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.5em 1em;
      opacity: 0.97;
      pointer-events: none;
      animation: fomo-fadein 0.4s;
      backdrop-filter: blur(2px);
      border: 2px solid #14F195;
    }

    .fomo-popup::before {
      content: "‚ö°";
      font-size: 1.3em;
      margin-right: 0.6em;
      filter: drop-shadow(0 0 4px #FFD700);
      opacity: 0.85;
    }

    @keyframes fomo-fadein {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }

      to {
        opacity: 0.97;
        transform: translateX(-50%) translateY(0);
      }
    }

    .game-board-wrapper {
      width: 100vw;
      max-width: var(--max-board);
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 auto 0 auto;
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      z-index: 2;
      position: relative;
    }

    .game-board {
      width: var(--board-size);
      max-width: var(--max-board);
      aspect-ratio: 1/1;
      background: #000;
      border: 4px solid var(--neon);
      box-shadow: 0 0 32px 8px var(--neon);
      border-radius: 12px;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
    }

    .level-indicator {
      position: absolute;
      top: 8px;
      left: 8px;
      color: var(--neon-green);
      font-size: 1rem;
      z-index: 5;
      text-shadow: var(--neon-green-glow);
      font-family: inherit;
    }

    .player,
    .ghost,
    .candle,
    .wall,
    .bullet {
      position: absolute;
    }

    .player {
      width: 15px;
      height: 15px;
      z-index: 10;
    }

    .ghost {
      width: 15px;
      height: 15px;
      z-index: 5;
    }

    .candle {
      width: 4px;
      height: 4px;
      z-index: 3;
      border-radius: 50%;
      background-color: #FFD700;
      box-shadow: 0 0 6px #FFD700;
    }

    .candle.power-candle {
      width: 10px;
      height: 10px;
      background-color: #00FFFA;
      box-shadow: 0 0 12px #00FFFA, 0 0 4px #00FFFA;
      border: 2px solid #fff;
    }

    .candle.big-candle {
      width: 10px !important;
      height: 10px !important;
      background: #FFD700;
      border: 2px solid #FF4500;
      box-shadow: 0 0 14px #FFD700, 0 0 6px #FF4500;
      z-index: 12;
      animation: big-candle-blink 0.5s steps(1) infinite;
    }

    @keyframes big-candle-blink {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }

      100% {
        opacity: 1;
      }
    }

    .candle.candle-pulse {
      animation: candle-pulse 1s infinite;
    }

    @keyframes candle-pulse {
      0% {
        box-shadow: 0 0 6px #14F195;
      }

      50% {
        box-shadow: 0 0 18px #14F195;
      }

      100% {
        box-shadow: 0 0 6px #14F195;
      }
    }

    .candle.candle-spin {
      animation: candle-spin 1.2s linear infinite;
    }

    @keyframes candle-spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .candle.candle-shake {
      animation: candle-shake 0.4s infinite;
    }

    @keyframes candle-shake {
      0% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-2px);
      }

      50% {
        transform: translateX(2px);
      }

      75% {
        transform: translateX(-2px);
      }

      100% {
        transform: translateX(0);
      }
    }

    .candle.candle-blink {
      animation: candle-blink 0.7s steps(1) infinite;
    }

    @keyframes candle-blink {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }

      100% {
        opacity: 1;
      }
    }

    .candle.candle-glow {
      box-shadow: 0 0 18px #FFD700, 0 0 8px #fff;
    }

    .wall {
      background-color: #14F195;
      z-index: 2;
      border-radius: 2px;
      box-shadow: 0 0 10px #14F195, 0 0 2px #14F195;
    }

    .bullet {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #00FFFA;
      box-shadow: 0 0 8px #00FFFA;
      z-index: 20;
      pointer-events: none;
    }

    .game-over,
    .level-complete,
    .start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .score-panel,
    .controls {
      display: none;
    }

    .controls-row {
      width: 100vw;
      max-width: var(--max-board);
      margin: 0 auto;
      margin-top: 1.5em;
      margin-bottom: 1em;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      z-index: 10;
      pointer-events: none;
      position: relative;
      height: 140px;
    }

    .joystick-outer {
      position: relative;
      left: 0;
      bottom: 0;
      width: 120px;
      height: 120px;
      z-index: 1000;
      pointer-events: auto;
      touch-action: none;
      display: block;
    }

    .joystick-base {
      position: absolute;
      left: 0;
      top: 0;
      width: 120px;
      height: 120px;
      background: rgba(153, 69, 255, 0.25);
      border-radius: 50%;
      border: 3px solid #9945FF;
      box-shadow: 0 0 24px #9945FF88;
      pointer-events: none;
      touch-action: none;
    }

    .joystick-stick {
      position: absolute;
      left: 40px;
      top: 40px;
      width: 40px;
      height: 40px;
      background: #14F195;
      border-radius: 50%;
      border: 3px solid #fff;
      box-shadow: 0 0 16px #14F19588;
      pointer-events: none;
      touch-action: none;
      transition: background 0.1s;
    }

    .abtns {
      width: 180px;
      height: 180px;
      margin-right: 1cm;
      position: relative;
      display: flex;
      justify-content: flex-end;
      align-items: flex-end;
      pointer-events: auto;
    }

    .abtn {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 90px;
      height: 90px;
      background: #e74c3c;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2.2rem;
      color: #fff;
      font-weight: bold;
      border: 4px solid #fff;
      box-shadow: 0 2px 16px #e74c3c88;
      opacity: 0.4;
      pointer-events: auto;
      transition: background 0.1s, transform 0.1s, opacity 0.2s;
      font-family: inherit;
    }

    .abtn.active {
      opacity: 1;
      background: #e74c3c;
      color: #fff;
    }

    .abtn:active {
      background: #c0392b;
      opacity: 1;
      transform: scale(0.95);
    }

    .game-description {
      color: #fff;
      font-size: 1.08em;
      margin-bottom: 1em;
      margin-top: 0.5em;
      line-height: 1.5;
      text-align: center;
      font-family: 'Share Tech Mono', monospace;
    }

    .lottery-intro {
      background: #181828;
      color: #fff;
      border-radius: 10px;
      padding: 12px 10px;
      margin: 0 auto 10px auto;
      max-width: 320px;
      box-shadow: 0 0 16px #9945FF44;
      font-family: 'Share Tech Mono', monospace;
      text-align: center;
    }

    .lottery-brief {
      font-size: 1.05em;
      margin-bottom: 8px;
    }

    .lottery-actions button {
      background: #14F195;
      color: #181828;
      font-weight: bold;
      border: none;
      border-radius: 7px;
      padding: 7px 16px;
      margin: 0 3px 7px 3px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.2s;
      font-family: inherit;
    }

    .lottery-actions button:hover {
      background: #00e676;
    }

    .lottery-details {
      background: #222;
      color: #FFD700;
      border-radius: 7px;
      padding: 8px 7px;
      margin-top: 7px;
      font-size: 0.98em;
      display: none;
    }

    .lottery-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 15, 26, 0.92);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lottery-modal-content {
      background: #181828;
      color: #fff;
      border-radius: 12px;
      padding: 28px 22px 18px 22px;
      max-width: 340px;
      width: 90vw;
      box-shadow: 0 0 32px #9945FF77;
      text-align: center;
      font-family: 'Share Tech Mono', monospace;
    }

    .lottery-modal-text {
      font-size: 1.08em;
      margin-bottom: 18px;
      color: #FFD700;
      line-height: 1.5;
    }

    .lottery-modal-actions button {
      background: #14F195;
      color: #181828;
      font-weight: bold;
      border: none;
      border-radius: 7px;
      padding: 9px 22px;
      margin: 0 8px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.2s;
      font-family: inherit;
    }

    .lottery-modal-actions button:hover {
      background: #00e676;
    }

    .fomo-timer {
      position: absolute;
      top: 8px;
      right: 12px;
      z-index: 50;
      color: #fff;
      font-size: 1.18em;
      font-family: 'Share Tech Mono', monospace;
      font-weight: bold;
      text-shadow:
        0 0 2px #fff,
        0 0 6px #fff,
        0 0 0 #fff,
        1px 1px 0 #ff9800,
        -1px -1px 0 #ff4500,
        2px 2px 2px #ff9800,
        -2px -2px 2px #ff4500;
      background: none !important;
      border: none !important;
      padding: 0;
      margin: 0;
      border-radius: 0;
      box-shadow: none;
      pointer-events: none;
      transition: opacity 0.2s;
      opacity: 1;
    }

    .fomo-timer.fomo-blink {
      animation: fomo-blink 0.5s steps(1) infinite;
    }

    @keyframes fomo-blink {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }

      100% {
        opacity: 1;
      }
    }

    @media (max-width: 500px) {
      .abtns {
        width: 100px;
        height: 100px;
        margin-right: 0.5cm;
      }

      .abtn {
        width: 48px;
        height: 48px;
        font-size: 1.3rem;
      }

      .joystick-outer {
        width: 80px;
        height: 80px;
      }

      .joystick-base {
        width: 80px;
        height: 80px;
      }

      .joystick-stick {
        width: 28px;
        height: 28px;
        left: 26px;
        top: 26px;
      }
    }

    @media (max-width: 350px) {
      .abtns {
        width: 60px;
        height: 60px;
        margin-right: 0.5cm;
      }

      .abtn {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
      }

      .joystick-outer {
        width: 60px;
        height: 60px;
      }

      .joystick-base {
        width: 60px;
        height: 60px;
      }

      .joystick-stick {
        width: 20px;
        height: 20px;
        left: 20px;
        top: 20px;
      }
    }

    html,
    body {
      overscroll-behavior: none;
    }
  </style>
</head>

<body>
  <!-- Language Switcher -->
  <div id="lang-switcher"
    style="position: fixed; top: 10px; right: 10px; z-index: 9999; background: rgba(20,20,40,0.92); border-radius: 6px; box-shadow: 0 2px 8px #9945FF33; padding: 2px 7px; display: flex; align-items: center; font-family: 'Share Tech Mono', monospace; font-size: 0.92em;">
    <span id="lang-icon" style="color:#FFD700; font-size:1em; margin-right:4px; cursor:pointer;">üåê</span>
    <select id="lang-select"
      style="background: #181828; color: #FFD700; border: 1px solid #9945FF; border-radius: 4px; font-size: 0.92em; padding: 1.5px 5px; outline: none; font-family: inherit; cursor: pointer; transition: border 0.2s; display: none;">
      <option value="ru">–†—É—Å—Å–∫–∏–π</option>
      <option value="en">English</option>
      <option value="es">Espa√±ol</option>
      <option value="de">Deutsch</option>
      <option value="fr">Fran√ßais</option>
      <option value="it">Italiano</option>
      <option value="zh">‰∏≠Êñá</option>
      <option value="ua">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
    </select>
  </div>
  <div class="console-header">
    <div class="console-title">DEGEN-MAN</div>
    <div id="collection-profile" class="collection-profile"></div>
    <div class="console-status">
      <span data-translate-key="poorLabel">$POOR:</span> <span id="score">0</span>¬†¬†<span
        data-translate-key="livesLabel">LIVES:</span> <span id="lives">3</span>
    </div>
    <div class="console-quest" id="console-quest">
    </div>
    <div id="fomo-popup" class="fomo-popup" style="display:none;"></div>
  </div>
  <div class="game-board-wrapper">
    <div class="game-board" id="game-board">
      <div class="level-indicator" id="level-indicator"><span data-translate-key="levelLabel">LEVEL</span> 1</div>
      <div id="fomo-timer" class="fomo-timer" style="display:none;"></div>
      <div class="start-screen" id="start-screen">
        <h2 style="color:#9945FF;text-shadow:0 0 8px #9945FF;">DEGEN-MAN</h2>
        <div class="game-description" id="game-description" data-translate-key="gameDescription">
        </div>
        <button class="btn" id="start-btn" style="margin:18px 0 0 0;" data-translate-key="startGameBtn">START
          GAME</button>
        <div id="lottery-intro" class="lottery-intro" style="margin-top:18px;">
          <div class="lottery-brief">
            <b data-translate-key="lotteryTitle">Weekly Lottery!</b><br>
            <span data-translate-key="lotterySlogan">Pay $1 ‚Äî win a big prize.</span><br>
            <span data-translate-key="prizePool">Prize pool:</span> <span id="prize-amount">$4,200</span>
          </div>
          <div class="lottery-actions">
            <button id="buy-ticket-btn" data-translate-key="buyTicketBtn">Buy Ticket</button>
            <button id="show-rules-btn" data-translate-key="howItWorksBtn">How it works</button>
            <button id="skip-lottery-btn" data-translate-key="skipBtn">Skip</button>
          </div>
          <div id="lottery-details" class="lottery-details" style="display:none;"></div>
        </div>
        <div id="lottery-modal" class="lottery-modal" style="display:none;">
          <div class="lottery-modal-content">
            <div id="lottery-modal-text" class="lottery-modal-text"></div>
            <div class="lottery-modal-actions">
              <button id="modal-buy-ticket-btn" data-translate-key="buyTicketBtn">Buy Ticket</button>
              <button id="modal-skip-btn" data-translate-key="skipBtn">Skip</button>
            </div>
          </div>
        </div>
      </div>
      <div class="game-over" id="game-over" style="display: none;">
        <h2 data-translate-key="gameOverTitle">GAME OVER</h2>
        <p><span data-translate-key="finalScoreLabel">Final Score:</span> <span id="final-score">0</span></p>
        <p><span data-translate-key="levelReachedLabel">Level Reached:</span> <span id="final-level">1</span></p>
        <button class="btn" id="restart-btn" data-translate-key="tryAgainBtn">TRY AGAIN</button>
      </div>
      <div class="level-complete" id="level-complete" style="display: none;">
        <h2><span data-translate-key="levelLabel">LEVEL</span> <span id="completed-level">1</span> <span
            data-translate-key="completeLabel">COMPLETE!</span></h2>
        <p><span data-translate-key="currentScoreLabel">Current Score:</span> <span id="level-score">0</span></p>
        <p data-translate-key="nextLevelMsg">Get ready for the next level...</p>
      </div>
    </div>
  </div>
  <div class="controls-row">
    <div class="joystick-outer" id="joystick-outer">
      <div class="joystick-base"></div>
      <div class="joystick-stick" id="joystick-stick"></div>
    </div>
    <div class="abtns">
      <div class="abtn" id="abtn-a"><span>A</span></div>
    </div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø TELEGRAM WEB APP ---
    if (window.Telegram && window.Telegram.WebApp) {
      window.Telegram.WebApp.ready();
    }

    // --- Web Audio API: –ø—Ä–æ—Å—Ç—ã–µ –∑–≤—É–∫–∏ ---
    let audioCtx;

    function playTone(freq, duration = 0.1, type = "sine", volume = 0.2) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };
    }

    function playCandleSound() {
      playTone(880, 0.07, "triangle", 0.15);
    }

    function playPowerCandleSound() {
      playTone(440, 0.18, "square", 0.18);
    }

    function playBigCandleSound() {
      playTone(523, 0.25, "sine", 0.2);
      playTone(659, 0.25, "sine", 0.2);
    }

    function playDeathSound() {
      playTone(110, 0.25, "sawtooth", 0.22);
    }

    function playLevelSound() {
      playTone(523, 0.08, "triangle", 0.18);
      setTimeout(() => playTone(659, 0.08, "triangle", 0.18), 90);
      setTimeout(() => playTone(784, 0.12, "triangle", 0.18), 180);
    }

    // --- Translation System ---
    const translations = {
      ru: {
        questPrompt: `–ü—Ä–∏–¥—É–º–∞–π –∫–æ—Ä–æ—Ç–∫–æ–µ —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –∞—Ä–∫–∞–¥–Ω–æ–π –∏–≥—Ä—ã –≤ —Å—Ç–∏–ª–µ Pac-Man. –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ —Ç–∞–∫–∏–µ –∏–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã: —Å–≤–µ—á–∏ (–∑–µ–ª—ë–Ω—ã–µ, —Å–∏–Ω–∏–µ, –∫—Ä–∞—Å–Ω—ã–µ, –∂—ë–ª—Ç—ã–µ, —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–µ, –∑–æ–ª–æ—Ç—ã–µ), –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–Ω—ã–µ —Å–≤–µ—á–∏, –ø—Ä–∏–∑—Ä–∞–∫–∏. –ù–µ –ø—Ä–∏–¥—É–º—ã–≤–∞–π –Ω–æ–≤—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ —ç—Ç–æ–º —Å–ø–∏—Å–∫–µ. –§–æ—Ä–º–∞—Ç –∑–∞–¥–∞–Ω–∏—è: –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞, –±–µ–∑ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–π –∏ –ø–æ—è—Å–Ω–µ–Ω–∏–π.`,
        poorLabel: "$POOR:",
        livesLabel: "–ñ–ò–ó–ù–ò:",
        levelLabel: "–£–†–û–í–ï–ù–¨",
        collectionLabel: "–ö–æ–ª–ª–µ–∫—Ü–∏—è:",
        gameDescription: `–ò–≥—Ä–∞–π, –≤—ã–ø–æ–ª–Ω—è–π –∑–∞–¥–∞–Ω–∏—è –∏ –ø–æ–ª—É—á–∞–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ª–æ—Ç–µ—Ä–µ–π–Ω—ã–π –±–∏–ª–µ—Ç!<br>–°–æ–±–∏—Ä–∞–π –∑–µ–ª—ë–Ω—ã–µ —Å–≤–µ—á–∏, –∏–∑–±–µ–≥–∞–π F.U.D.<br><span style="color:#14F195;">–°–∏–ª–∞-—Å–≤–µ—á–∞:</span> —Å—Ç—Ä–µ–ª—è–π —Å –ø–æ–º–æ—â—å—é –ü—Ä–æ–±–µ–ª–∞, J –∏–ª–∏ A.`,
        startGameBtn: "–ù–ê–ß–ê–¢–¨ –ò–ì–†–£",
        lotteryTitle: "–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–∞—è –ª–æ—Ç–µ—Ä–µ—è!",
        lotterySlogan: "–ó–∞–ø–ª–∞—Ç–∏ $1 ‚Äî –≤—ã–∏–≥—Ä–∞–π –±–æ–ª—å—à–æ–π –ø—Ä–∏–∑.",
        prizePool: "–ü—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥:",
        buyTicketBtn: "–ö—É–ø–∏—Ç—å –±–∏–ª–µ—Ç",
        howItWorksBtn: "–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç",
        skipBtn: "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
        lotteryRules: `<b>–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?</b><br>1. –ö—É–ø–∏ –±–∏–ª–µ—Ç –∑–∞ $1.<br>2. –ù–∞–±–ª—é–¥–∞–π, –∫–∞–∫ —Ä–∞—Å—Ç—ë—Ç –ø—Ä–∏–∑–æ–≤–æ–π —Ñ–æ–Ω–¥.<br>3. –î–æ–∂–¥–∏—Å—å –ø—è—Ç–Ω–∏—Ü—ã 21:00 ‚Äî –∏ –≤—ã–∏–≥—Ä–∞–π!<br><br><b>–ê–Ω–æ–Ω–∏–º–Ω–æ, –ø—Ä–æ—Å—Ç–æ, –±–µ–∑–æ–ø–∞—Å–Ω–æ.</b><br>–û–ø–ª–∞—Ç–∞ –∏ –≤—ã–ø–ª–∞—Ç–∞ ‚Äî —á–µ—Ä–µ–∑ –∫—Ä–∏–ø—Ç–æ–∫–æ—à–µ–ª—ë–∫.<br><br><span style="color:#14F195;">–í—ã–ø–æ–ª–Ω—è–π –∫–≤–µ—Å—Ç—ã –≤ –∏–≥—Ä–µ –∏ –ø–æ–ª—É—á–∞–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –±–∏–ª–µ—Ç –∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é!</span>`,
        ticketPurchased: "–ë–∏–ª–µ—Ç –∫—É–ø–ª–µ–Ω! –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ –≤ —ç—Ç—É –ø—è—Ç–Ω–∏—Ü—É.<br>–£–¥–∞—á–∏!",
        gameOverTitle: "–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê",
        finalScoreLabel: "–ò—Ç–æ–≥–æ–≤—ã–π —Å—á—ë—Ç:",
        levelReachedLabel: "–î–æ—Å—Ç–∏–≥–Ω—É—Ç—ã–π —É—Ä–æ–≤–µ–Ω—å:",
        tryAgainBtn: "–ü–û–ü–†–û–ë–û–í–ê–¢–¨ –°–ù–û–í–ê",
        completeLabel: "–ü–†–û–ô–î–ï–ù!",
        currentScoreLabel: "–¢–µ–∫—É—â–∏–π —Å—á—ë—Ç:",
        nextLevelMsg: "–ü—Ä–∏–≥–æ—Ç–æ–≤—å—Ç–µ—Å—å –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É—Ä–æ–≤–Ω—é...",
        questLabel: "–ó–∞–¥–∞–Ω–∏–µ",
        generatingQuest: "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–¥–∞–Ω–∏—è...",
        questFetchError: "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ.",
        fomoPopupCollect: "–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–Ω–∞—è —Å–≤–µ—á–∞! ({name})<br>–°–æ–±–µ—Ä–∏ –µ—ë –∑–∞ 10 —Å–µ–∫—É–Ω–¥!",
        fomoPopupBigCandle: "–ë–æ–ª—å—à–∞—è —Å–≤–µ—á–∞! –°–æ–±–µ—Ä–∏ –µ—ë –∑–∞ 10 —Å–µ–∫—É–Ω–¥ –∏ –ø–æ–ª—É—á–∏ +100 $POOR!",
        fomoPopupMissedCollection: "–¢—ã —É–ø—É—Å—Ç–∏–ª –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–Ω—É—é —Å–≤–µ—á—É!",
        fomoPopupMissedBig: "–ë–æ–ª—å—à–∞—è —Å–≤–µ—á–∞ –∏—Å—á–µ–∑–ª–∞!",
        fomoTimer: "–û—Å—Ç–∞–ª–æ—Å—å: {seconds} —Å–µ–∫.",
        collectedNew: "–ù–æ–≤–∞—è —Å–≤–µ—á–∞ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏! –°–æ–±–µ—Ä–∏ –≤—Å–µ –¥–ª—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –Ω–∞–≥—Ä–∞–¥—ã!",
        collectedAgain: "–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–Ω–∞—è —Å–≤–µ—á–∞ —Å–æ–±—Ä–∞–Ω–∞ —Å–Ω–æ–≤–∞!",
        bigCandleBonus: "+100 $POOR –∑–∞ –±–æ–ª—å—à—É—é —Å–≤–µ—á—É!",
        questDefaultFallback: "–°–æ–±–µ—Ä–∏ –≤—Å–µ —Å–≤–µ—á–∏!",
      },
      en: {
        questPrompt: `Come up with a short unique quest for an arcade game in the style of Pac-Man. Use only these game objects: candles (green, blue, red, yellow, purple, gold), collectible candles, ghosts. Do not invent new items not in this list. The quest should be one line, no greetings or explanations.`,
        poorLabel: "$POOR:",
        livesLabel: "LIVES:",
        levelLabel: "LEVEL",
        collectionLabel: "Collection:",
        gameDescription: `Play, complete quests, and get a free lottery ticket!<br>Collect green candles, avoid F.U.D.<br><span style="color:#14F195;">Power-candle:</span> shoot with Space, J or A.`,
        startGameBtn: "START GAME",
        lotteryTitle: "Weekly Lottery!",
        lotterySlogan: "Pay $1 ‚Äî win a big prize.",
        prizePool: "Prize pool:",
        buyTicketBtn: "Buy Ticket",
        howItWorksBtn: "How it works",
        skipBtn: "Skip",
        lotteryRules: `<b>How does it work?</b><br>1. Buy a ticket for $1.<br>2. Watch the prize pool grow in real time.<br>3. Wait for Friday 21:00 ‚Äî and win!<br><br><b>Anonymous, simple, safe.</b><br>Payment and payout ‚Äî via crypto wallet.<br><br><span style="color:#14F195;">Complete quests in-game and get a free ticket every week!</span>`,
        ticketPurchased: "Ticket purchased! You're in this Friday's draw.<br>Good luck!",
        gameOverTitle: "GAME OVER",
        finalScoreLabel: "Final Score:",
        levelReachedLabel: "Level Reached:",
        tryAgainBtn: "TRY AGAIN",
        completeLabel: "COMPLETE!",
        currentScoreLabel: "Current Score:",
        nextLevelMsg: "Get ready for the next level...",
        questLabel: "Quest",
        generatingQuest: "Generating quest...",
        questFetchError: "Failed to load quest.",
        fomoPopupCollect: "Collection Candle! ({name})<br>Collect it in 10 seconds!",
        fomoPopupBigCandle: "Big candle! Collect it in 10 seconds for +100 $POOR bonus!",
        fomoPopupMissedCollection: "You missed the Collection Candle!",
        fomoPopupMissedBig: "Big candle disappeared!",
        fomoTimer: "Time left: {seconds} sec.",
        collectedNew: "New Candle Collected! Complete the set for a secret reward!",
        collectedAgain: "Collection Candle collected again!",
        bigCandleBonus: "+100 $POOR for big candle!",
        questDefaultFallback: "Collect all the candles!",
      },
      es: {
        questPrompt: `Crea una misi√≥n corta y √∫nica para un juego tipo Pac-Man. Usa solo estos objetos: velas (verde, azul, roja, amarilla, p√∫rpura, dorada), velas coleccionables, fantasmas. No inventes objetos nuevos. La misi√≥n debe ser una l√≠nea, sin saludos.`,
        poorLabel: "$POOR:",
        livesLabel: "VIDAS:",
        levelLabel: "NIVEL",
        collectionLabel: "Colecci√≥n:",
        gameDescription: `¬°Juega, completa misiones y consigue un ticket de loter√≠a gratis!<br>Recoge velas verdes, evita a los F.U.D.<br><span style="color:#14F195;">Vela de poder:</span> dispara con Espacio, J o A.`,
        startGameBtn: "EMPEZAR JUEGO",
        lotteryTitle: "¬°Loter√≠a Semanal!",
        lotterySlogan: "Paga $1 ‚Äî gana un gran premio.",
        prizePool: "Bote de premios:",
        buyTicketBtn: "Comprar Ticket",
        howItWorksBtn: "C√≥mo funciona",
        skipBtn: "Saltar",
        lotteryRules: `<b>¬øC√≥mo funciona?</b><br>1. Compra un ticket por $1.<br>2. Mira c√≥mo crece el bote.<br>3. ¬°Espera al viernes a las 21:00 y gana!<br><br><b>An√≥nimo, simple, seguro.</b><br>Pago y cobro v√≠a cripto-billetera.<br><br><span style="color:#14F195;">¬°Completa misiones y obt√©n un ticket gratis cada semana!</span>`,
        ticketPurchased: "¬°Ticket comprado! Est√°s en el sorteo de este viernes.<br>¬°Buena suerte!",
        gameOverTitle: "JUEGO TERMINADO",
        finalScoreLabel: "Puntuaci√≥n Final:",
        levelReachedLabel: "Nivel Alcanzado:",
        tryAgainBtn: "INTENTAR DE NUEVO",
        completeLabel: "¬°COMPLETADO!",
        currentScoreLabel: "Puntuaci√≥n Actual:",
        nextLevelMsg: "Prep√°rate para el siguiente nivel...",
        questLabel: "Misi√≥n",
        generatingQuest: "Generando misi√≥n...",
        questFetchError: "Fallo al cargar la misi√≥n.",
        fomoPopupCollect: "¬°Vela de Colecci√≥n! ({name})<br>¬°Rec√≥gela en 10 segundos!",
        fomoPopupBigCandle: "¬°Vela grande! ¬°Rec√≥gela en 10s por +100 $POOR!",
        fomoPopupMissedCollection: "¬°Perdiste la vela de colecci√≥n!",
        fomoPopupMissedBig: "¬°La vela grande desapareci√≥!",
        fomoTimer: "Tiempo: {seconds} seg.",
        collectedNew: "¬°Nueva vela en la colecci√≥n! ¬°Compl√©talas todas para un premio!",
        collectedAgain: "¬°Vela de colecci√≥n recogida de nuevo!",
        bigCandleBonus: "¬°+100 $POOR por la vela grande!",
        questDefaultFallback: "¬°Recoge todas las velas!",
      },
      de: {
        questPrompt: `Erfinde eine kurze, einzigartige Aufgabe f√ºr ein Arcade-Spiel im Pac-Man-Stil. Verwende nur diese Spielobjekte: Kerzen (gr√ºn, blau, rot, gelb, lila, gold), Sammelkerzen, Geister. Erfinde keine neuen Gegenst√§nde. Die Aufgabe sollte eine Zeile sein.`,
        poorLabel: "$POOR:",
        livesLabel: "LEBEN:",
        levelLabel: "LEVEL",
        collectionLabel: "Sammlung:",
        gameDescription: `Spiele, erf√ºlle Quests und erhalte ein kostenloses Lotterielos!<br>Sammle gr√ºne Kerzen, meide F.U.D.<br><span style="color:#14F195;">Power-Kerze:</span> Schie√üe mit Leertaste, J oder A.`,
        startGameBtn: "SPIEL STARTEN",
        lotteryTitle: "W√∂chentliche Lotterie!",
        lotterySlogan: "Zahle $1 ‚Äì gewinne einen gro√üen Preis.",
        prizePool: "Preispool:",
        buyTicketBtn: "Ticket kaufen",
        howItWorksBtn: "So geht's",
        skipBtn: "√úberspringen",
        lotteryRules: `<b>Wie funktioniert es?</b><br>1. Kaufe ein Ticket f√ºr $1.<br>2. Sieh zu, wie der Preispool w√§chst.<br>3. Warte auf Freitag 21:00 Uhr ‚Äì und gewinne!<br><br><b>Anonym, einfach, sicher.</b><br>Zahlung und Auszahlung ‚Äì √ºber Krypto-Wallet.<br><br><span style="color:#14F195;">Erf√ºlle Quests im Spiel und erhalte jede Woche ein kostenloses Ticket!</span>`,
        ticketPurchased: "Ticket gekauft! Du nimmst an der Ziehung diesen Freitag teil.<br>Viel Gl√ºck!",
        gameOverTitle: "SPIEL VORBEI",
        finalScoreLabel: "Endstand:",
        levelReachedLabel: "Erreichtes Level:",
        tryAgainBtn: "ERNEUT VERSUCHEN",
        completeLabel: "ABGESCHLOSSEN!",
        currentScoreLabel: "Aktueller Punktestand:",
        nextLevelMsg: "Mach dich bereit f√ºr das n√§chste Level...",
        questLabel: "Quest",
        generatingQuest: "Quest wird generiert...",
        questFetchError: "Quest konnte nicht geladen werden.",
        fomoPopupCollect: "Sammelkerze! ({name})<br>Sammle sie in 10 Sekunden!",
        fomoPopupBigCandle: "Gro√üe Kerze! Sammle sie in 10 Sekunden f√ºr +100 $POOR Bonus!",
        fomoPopupMissedCollection: "Du hast die Sammelkerze verpasst!",
        fomoPopupMissedBig: "Die gro√üe Kerze ist verschwunden!",
        fomoTimer: "Verbleibende Zeit: {seconds} Sek.",
        collectedNew: "Neue Kerze gesammelt! Vervollst√§ndige das Set f√ºr eine Belohnung!",
        collectedAgain: "Sammelkerze erneut gesammelt!",
        bigCandleBonus: "+100 $POOR f√ºr die gro√üe Kerze!",
        questDefaultFallback: "Sammle alle Kerzen!",
      },
      fr: {
        questPrompt: `Invente une qu√™te courte et unique pour un jeu d'arcade de style Pac-Man. Utilise uniquement ces objets de jeu : bougies (vert, bleu, rouge, jaune, violet, or), bougies de collection, fant√¥mes. N'invente pas de nouveaux objets. La qu√™te doit √™tre une seule ligne.`,
        poorLabel: "$POOR:",
        livesLabel: "VIES:",
        levelLabel: "NIVEAU",
        collectionLabel: "Collection:",
        gameDescription: `Jouez, accomplissez des qu√™tes et obtenez un ticket de loterie gratuit !<br>R√©cup√©rez les bougies vertes, √©vitez les F.U.D.<br><span style="color:#14F195;">Super-bougie :</span> tirez avec Espace, J ou A.`,
        startGameBtn: "COMMENCER √Ä JOUER",
        lotteryTitle: "Loterie Hebdomadaire !",
        lotterySlogan: "Payez 1 $ ‚Äî gagnez un gros lot.",
        prizePool: "Cagnotte :",
        buyTicketBtn: "Acheter un billet",
        howItWorksBtn: "Comment √ßa marche",
        skipBtn: "Passer",
        lotteryRules: `<b>Comment √ßa marche ?</b><br>1. Achetez un billet pour 1 $.<br>2. Regardez la cagnotte augmenter.<br>3. Attendez vendredi 21h00 ‚Äî et gagnez !<br><br><b>Anonyme, simple, s√ªr.</b><br>Paiement et retrait ‚Äì via portefeuille crypto.<br><br><span style="color:#14F195;">Accomplissez des qu√™tes en jeu et obtenez un billet gratuit chaque semaine !</span>`,
        ticketPurchased: "Billet achet√© ! Vous participez au tirage de ce vendredi.<br>Bonne chance !",
        gameOverTitle: "PARTIE TERMIN√âE",
        finalScoreLabel: "Score final :",
        levelReachedLabel: "Niveau atteint :",
        tryAgainBtn: "R√âESSAYER",
        completeLabel: "TERMIN√â !",
        currentScoreLabel: "Score actuel :",
        nextLevelMsg: "Pr√©parez-vous pour le prochain niveau...",
        questLabel: "Qu√™te",
        generatingQuest: "G√©n√©ration de la qu√™te...",
        questFetchError: "√âchec du chargement de la qu√™te.",
        fomoPopupCollect: "Bougie de collection ! ({name})<br>R√©cup√©rez-la en 10 secondes !",
        fomoPopupBigCandle: "Grosse bougie ! R√©cup√©rez-la en 10 secondes pour un bonus de +100 $POOR !",
        fomoPopupMissedCollection: "Vous avez manqu√© la bougie de collection !",
        fomoPopupMissedBig: "La grosse bougie a disparu !",
        fomoTimer: "Temps restant : {seconds} sec.",
        collectedNew: "Nouvelle bougie collect√©e ! Compl√©tez l'ensemble pour une r√©compense secr√®te !",
        collectedAgain: "Bougie de collection r√©cup√©r√©e √† nouveau !",
        bigCandleBonus: "+100 $POOR pour la grosse bougie !",
        questDefaultFallback: "Collectez toutes les bougies !",
      },
      it: {
        questPrompt: `Inventa una missione breve e unica per un gioco arcade in stile Pac-Man. Usa solo questi oggetti di gioco: candele (verdi, blu, rosse, gialle, viola, oro), candele da collezione, fantasmi. Non inventare nuovi oggetti. La missione deve essere una sola riga.`,
        poorLabel: "$POOR:",
        livesLabel: "VITE:",
        levelLabel: "LIVELLO",
        collectionLabel: "Collezione:",
        gameDescription: `Gioca, completa le missioni e ottieni un biglietto della lotteria gratuito!<br>Raccogli le candele verdi, evita i F.U.D.<br><span style="color:#14F195;">Super-candela:</span> spara con Spazio, J o A.`,
        startGameBtn: "INIZIA PARTITA",
        lotteryTitle: "Lotteria Settimanale!",
        lotterySlogan: "Paga $1 ‚Äî vinci un grande premio.",
        prizePool: "Montepremi:",
        buyTicketBtn: "Compra biglietto",
        howItWorksBtn: "Come funziona",
        skipBtn: "Salta",
        lotteryRules: `<b>Come funziona?</b><br>1. Compra un biglietto per $1.<br>2. Guarda il montepremi crescere.<br>3. Aspetta venerd√¨ alle 21:00 ‚Äî e vinci!<br><br><b>Anonimo, semplice, sicuro.</b><br>Pagamento e incasso ‚Äì tramite portafoglio crypto.<br><br><span style="color:#14F195;">Completa le missioni in gioco e ottieni un biglietto gratuito ogni settimana!</span>`,
        ticketPurchased: "Biglietto acquistato! Partecipi all'estrazione di questo venerd√¨.<br>Buona fortuna!",
        gameOverTitle: "GIOCO FINITO",
        finalScoreLabel: "Punteggio finale:",
        levelReachedLabel: "Livello raggiunto:",
        tryAgainBtn: "RIPROVA",
        completeLabel: "COMPLETATO!",
        currentScoreLabel: "Punteggio attuale:",
        nextLevelMsg: "Preparati per il prossimo livello...",
        questLabel: "Missione",
        generatingQuest: "Generazione missione...",
        questFetchError: "Impossibile caricare la missione.",
        fomoPopupCollect: "Candela da collezione! ({name})<br>Raccoglila in 10 secondi!",
        fomoPopupBigCandle: "Candela grande! Raccoglila in 10 secondi per +100 $POOR di bonus!",
        fomoPopupMissedCollection: "Hai perso la candela da collezione!",
        fomoPopupMissedBig: "La candela grande √® scomparsa!",
        fomoTimer: "Tempo rimasto: {seconds} sec.",
        collectedNew: "Nuova candela raccolta! Completa il set per una ricompensa segreta!",
        collectedAgain: "Candela da collezione raccolta di nuovo!",
        bigCandleBonus: "+100 $POOR per la candela grande!",
        questDefaultFallback: "Raccogli tutte le candele!",
      },
      zh: {
        questPrompt: `‰∏∫‰∏ÄÊ¨æÂêÉË±Ü‰∫∫È£éÊ†ºÁöÑË°óÊú∫Ê∏∏ÊàèËÆæËÆ°‰∏Ä‰∏™ÁÆÄÁü≠ËÄåÁã¨ÁâπÁöÑ‰ªªÂä°„ÄÇÂè™‰ΩøÁî®Ëøô‰∫õÊ∏∏ÊàèÂØπË±°ÔºöËú°ÁÉõÔºàÁªøËâ≤„ÄÅËìùËâ≤„ÄÅÁ∫¢Ëâ≤„ÄÅÈªÑËâ≤„ÄÅÁ¥´Ëâ≤„ÄÅÈáëËâ≤Ôºâ„ÄÅÊî∂ËóèËú°ÁÉõ„ÄÅÈ¨ºÈ≠Ç„ÄÇ‰∏çË¶ÅÂèëÊòéÊñ∞Áâ©ÂìÅ„ÄÇ‰ªªÂä°Â∫îËØ•Âè™Êúâ‰∏ÄË°å„ÄÇ`,
        poorLabel: "$POOR:",
        livesLabel: "ÁîüÂëΩ:",
        levelLabel: "Á≠âÁ∫ß",
        collectionLabel: "Êî∂Ëóè:",
        gameDescription: `Áé©Ê∏∏ÊàèÔºåÂÆåÊàê‰ªªÂä°ÔºåËé∑ÂèñÂÖçË¥πÂΩ©Á•®ÔºÅ<br>Êî∂ÈõÜÁªøËâ≤Ëú°ÁÉõÔºåË∫≤ÈÅøF.U.D„ÄÇ<br><span style="color:#14F195;">ËÉΩÈáèËú°ÁÉõ:</span> ‰ΩøÁî®Á©∫Ê†º, JÊàñAÈîÆÂ∞ÑÂáª„ÄÇ`,
        startGameBtn: "ÂºÄÂßãÊ∏∏Êàè",
        lotteryTitle: "ÊØèÂë®ÊäΩÂ•ñÔºÅ",
        lotterySlogan: "ÊîØ‰ªò1ÁæéÂÖÉ ‚Äî Ëµ¢ÂèñÂ§ßÂ•ñ„ÄÇ",
        prizePool: "Â•ñÊ±†:",
        buyTicketBtn: "Ë¥≠‰π∞ÂΩ©Á•®",
        howItWorksBtn: "Ê∏∏ÊàèËßÑÂàô",
        skipBtn: "Ë∑≥Ëøá",
        lotteryRules: `<b>ÊÄé‰πàÁé©Ôºü</b><br>1. Ëä±1ÁæéÂÖÉË¥≠‰π∞ÂΩ©Á•®„ÄÇ<br>2. ËßÇÁúãÂ•ñÊ±†ÂÆûÊó∂Â¢ûÈïø„ÄÇ<br>3. Á≠âÂæÖÂë®‰∫îÊôö‰∏ä9ÁÇπ ‚Äî Ëµ¢ÂèñÂ§ßÂ•ñÔºÅ<br><br><b>ÂåøÂêç„ÄÅÁÆÄÂçï„ÄÅÂÆâÂÖ®„ÄÇ</b><br>ÈÄöËøáÂä†ÂØÜÈí±ÂåÖÊîØ‰ªòÂíåÊî∂Ê¨æ„ÄÇ<br><br><span style="color:#14F195;">Âú®Ê∏∏Êàè‰∏≠ÂÆåÊàê‰ªªÂä°ÔºåÊØèÂë®Ëé∑ÂæóÂÖçË¥πÂΩ©Á•®ÔºÅ</span>`,
        ticketPurchased: "Â∑≤Ë¥≠‰π∞ÂΩ©Á•®ÔºÅÊÇ®Â∑≤ÂèÇÂä†Êú¨Âë®‰∫îÁöÑÊäΩÂ•ñ„ÄÇ<br>Á•ùÊÇ®Â•ΩËøêÔºÅ",
        gameOverTitle: "Ê∏∏ÊàèÁªìÊùü",
        finalScoreLabel: "ÊúÄÁªàÂæóÂàÜ:",
        levelReachedLabel: "ËææÂà∞Á≠âÁ∫ß:",
        tryAgainBtn: "ÂÜçËØï‰∏ÄÊ¨°",
        completeLabel: "ÂÆåÊàêÔºÅ",
        currentScoreLabel: "ÂΩìÂâçÂæóÂàÜ:",
        nextLevelMsg: "ÂáÜÂ§áÂ•ΩËøõÂÖ•‰∏ã‰∏ÄÂÖ≥...",
        questLabel: "‰ªªÂä°",
        generatingQuest: "Ê≠£Âú®ÁîüÊàê‰ªªÂä°...",
        questFetchError: "Âä†ËΩΩ‰ªªÂä°Â§±Ë¥•„ÄÇ",
        fomoPopupCollect: "Êî∂ËóèËú°ÁÉõÔºÅ({name})<br>Âú®10ÁßíÂÜÖÊî∂ÈõÜÂÆÉÔºÅ",
        fomoPopupBigCandle: "Â§ßËú°ÁÉõÔºÅÂú®10ÁßíÂÜÖÊî∂ÈõÜÂÆÉ‰ª•Ëé∑Âæó+100 $POORÂ•ñÂä±ÔºÅ",
        fomoPopupMissedCollection: "ÊÇ®ÈîôËøá‰∫ÜÊî∂ËóèËú°ÁÉõÔºÅ",
        fomoPopupMissedBig: "Â§ßËú°ÁÉõÊ∂àÂ§±‰∫ÜÔºÅ",
        fomoTimer: "Ââ©‰ΩôÊó∂Èó¥: {seconds}Áßí",
        collectedNew: "Êî∂ÈõÜÂà∞Êñ∞ÁöÑËú°ÁÉõÔºÅÈõÜÈΩêÊâÄÊúâ‰ª•Ëé∑ÂæóÁ•ûÁßòÂ•ñÂä±ÔºÅ",
        collectedAgain: "ÂÜçÊ¨°Êî∂ÈõÜÂà∞Êî∂ËóèËú°Áá≠ÔºÅ",
        bigCandleBonus: "Â§ßËú°ÁÉõÂ•ñÂä±+100 $POORÔºÅ",
        questDefaultFallback: "Êî∂ÈõÜÊâÄÊúâËú°ÁÉõÔºÅ",
      },
      ua: {
        questPrompt: `–ü—Ä–∏–¥—É–º–∞–π –∫–æ—Ä–æ—Ç–∫–µ —É–Ω—ñ–∫–∞–ª—å–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –∞—Ä–∫–∞–¥–Ω–æ—ó –≥—Ä–∏ –≤ —Å—Ç–∏–ª—ñ Pac-Man. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π —Ç—ñ–ª—å–∫–∏ —Ç–∞–∫—ñ —ñ–≥—Ä–æ–≤—ñ –æ–±'—î–∫—Ç–∏: —Å–≤—ñ—á–∫–∏ (–∑–µ–ª–µ–Ω—ñ, —Å–∏–Ω—ñ, —á–µ—Ä–≤–æ–Ω—ñ, –∂–æ–≤—Ç—ñ, —Ñ—ñ–æ–ª–µ—Ç–æ–≤—ñ, –∑–æ–ª–æ—Ç—ñ), –∫–æ–ª–µ–∫—Ü—ñ–π–Ω—ñ —Å–≤—ñ—á–∫–∏, –ø—Ä–∏–≤–∏–¥–∏. –ù–µ –≤–∏–≥–∞–¥—É–π –Ω–æ–≤–∏—Ö –ø—Ä–µ–¥–º–µ—Ç—ñ–≤. –ó–∞–≤–¥–∞–Ω–Ω—è –º–∞—î –±—É—Ç–∏ –æ–¥–Ω–∏–º —Ä—è–¥–∫–æ–º.`,
        poorLabel: "$POOR:",
        livesLabel: "–ñ–ò–¢–¢–Ø:",
        levelLabel: "–†–Ü–í–ï–ù–¨",
        collectionLabel: "–ö–æ–ª–µ–∫—Ü—ñ—è:",
        gameDescription: `–ì—Ä–∞–π, –≤–∏–∫–æ–Ω—É–π –∑–∞–≤–¥–∞–Ω–Ω—è —Ç–∞ –æ—Ç—Ä–∏–º—É–π –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏–π –ª–æ—Ç–µ—Ä–µ–π–Ω–∏–π –∫–≤–∏—Ç–æ–∫!<br>–ó–±–∏—Ä–∞–π –∑–µ–ª–µ–Ω—ñ —Å–≤—ñ—á–∫–∏, —É–Ω–∏–∫–∞–π F.U.D.<br><span style="color:#14F195;">–°–∏–ª–æ–≤–∞-—Å–≤—ñ—á–∫–∞:</span> —Å—Ç—Ä—ñ–ª—è–π –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –ü—Ä–æ–±—ñ–ª—É, J –∞–±–æ A.`,
        startGameBtn: "–ü–û–ß–ê–¢–ò –ì–†–£",
        lotteryTitle: "–©–æ—Ç–∏–∂–Ω–µ–≤–∞ –ª–æ—Ç–µ—Ä–µ—è!",
        lotterySlogan: "–ó–∞–ø–ª–∞—Ç–∏ $1 ‚Äî –≤–∏–≥—Ä–∞–π –≤–µ–ª–∏–∫–∏–π –ø—Ä–∏–∑.",
        prizePool: "–ü—Ä–∏–∑–æ–≤–∏–π —Ñ–æ–Ω–¥:",
        buyTicketBtn: "–ö—É–ø–∏—Ç–∏ –∫–≤–∏—Ç–æ–∫",
        howItWorksBtn: "–Ø–∫ —Ü–µ –ø—Ä–∞—Ü—é—î",
        skipBtn: "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏",
        lotteryRules: `<b>–Ø–∫ —Ü–µ –ø—Ä–∞—Ü—é—î?</b><br>1. –ö—É–ø–∏ –∫–≤–∏—Ç–æ–∫ –∑–∞ $1.<br>2. –°–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞–π, —è–∫ –∑—Ä–æ—Å—Ç–∞—î –ø—Ä–∏–∑–æ–≤–∏–π —Ñ–æ–Ω–¥.<br>3. –î–æ—á–µ–∫–∞–π—Å—è –ø'—è—Ç–Ω–∏—Ü—ñ 21:00 ‚Äî —ñ –≤–∏–≥—Ä–∞–π!<br><br><b>–ê–Ω–æ–Ω—ñ–º–Ω–æ, –ø—Ä–æ—Å—Ç–æ, –±–µ–∑–ø–µ—á–Ω–æ.</b><br>–û–ø–ª–∞—Ç–∞ —Ç–∞ –≤–∏–ø–ª–∞—Ç–∞ ‚Äî —á–µ—Ä–µ–∑ –∫—Ä–∏–ø—Ç–æ–≥–∞–º–∞–Ω–µ—Ü—å.<br><br><span style="color:#14F195;">–í–∏–∫–æ–Ω—É–π –∫–≤–µ—Å—Ç–∏ –≤ –≥—Ä—ñ —Ç–∞ –æ—Ç—Ä–∏–º—É–π –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏–π –∫–≤–∏—Ç–æ–∫ —â–æ—Ç–∏–∂–Ω—è!</span>`,
        ticketPurchased: "–ö–≤–∏—Ç–æ–∫ –∫—É–ø–ª–µ–Ω–æ! –í–∏ –±–µ—Ä–µ—Ç–µ —É—á–∞—Å—Ç—å —É —Ä–æ–∑—ñ–≥—Ä–∞—à—ñ —Ü—ñ—î—ó –ø'—è—Ç–Ω–∏—Ü—ñ.<br>–£—Å–ø—ñ—Ö—ñ–≤!",
        gameOverTitle: "–ì–†–£ –ó–ê–í–ï–†–®–ï–ù–û",
        finalScoreLabel: "–ü—ñ–¥—Å—É–º–∫–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫:",
        levelReachedLabel: "–î–æ—Å—è–≥–Ω—É—Ç–∏–π —Ä—ñ–≤–µ–Ω—å:",
        tryAgainBtn: "–°–ü–†–û–ë–£–í–ê–¢–ò –©–ï",
        completeLabel: "–ü–†–û–ô–î–ï–ù–û!",
        currentScoreLabel: "–ü–æ—Ç–æ—á–Ω–∏–π —Ä–∞—Ö—É–Ω–æ–∫:",
        nextLevelMsg: "–ü—Ä–∏–≥–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è...",
        questLabel: "–ó–∞–≤–¥–∞–Ω–Ω—è",
        generatingQuest: "–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑–∞–≤–¥–∞–Ω–Ω—è...",
        questFetchError: "–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è.",
        fomoPopupCollect: "–ö–æ–ª–µ–∫—Ü—ñ–π–Ω–∞ —Å–≤—ñ—á–∫–∞! ({name})<br>–ó–±–µ—Ä–∏ —ó—ó –∑–∞ 10 —Å–µ–∫—É–Ω–¥!",
        fomoPopupBigCandle: "–í–µ–ª–∏–∫–∞ —Å–≤—ñ—á–∫–∞! –ó–±–µ—Ä–∏ —ó—ó –∑–∞ 10 —Å–µ–∫—É–Ω–¥ —ñ –æ—Ç—Ä–∏–º–∞–π +100 $POOR!",
        fomoPopupMissedCollection: "–¢–∏ –ø—Ä–æ–ø—É—Å—Ç–∏–≤ –∫–æ–ª–µ–∫—Ü—ñ–π–Ω—É —Å–≤—ñ—á–∫—É!",
        fomoPopupMissedBig: "–í–µ–ª–∏–∫–∞ —Å–≤—ñ—á–∫–∞ –∑–Ω–∏–∫–ª–∞!",
        fomoTimer: "–ó–∞–ª–∏—à–∏–ª–æ—Å—å: {seconds} —Å–µ–∫.",
        collectedNew: "–ù–æ–≤–∞ —Å–≤—ñ—á–∫–∞ –≤ –∫–æ–ª–µ–∫—Ü—ñ—ó! –ó–±–µ—Ä–∏ –≤—Å—ñ –¥–ª—è —Å–µ–∫—Ä–µ—Ç–Ω–æ—ó –Ω–∞–≥–æ—Ä–æ–¥–∏!",
        collectedAgain: "–ö–æ–ª–µ–∫—Ü—ñ–π–Ω—É —Å–≤—ñ—á–∫—É –∑—ñ–±—Ä–∞–Ω–æ –∑–Ω–æ–≤—É!",
        bigCandleBonus: "+100 $POOR –∑–∞ –≤–µ–ª–∏–∫—É —Å–≤—ñ—á–∫—É!",
        questDefaultFallback: "–ó–±–µ—Ä–∏ –≤—Å—ñ —Å–≤—ñ—á–∫–∏!",
      },
    };
    let currentLang = 'ru';

    function translateUI() {
      document.querySelectorAll('[data-translate-key]').forEach(el => {
        const key = el.dataset.translateKey;
        const translation = translations[currentLang]?.[key] || translations['en']?.[key] || key;
        if (translation) {
          el.innerHTML = translation;
        }
      });
      updateCollectionProfile();
      if (currentQuest) {
        showQuest(currentQuest);
      }
    }

    function getTranslation(key, params = {}) {
      let str = translations[currentLang]?.[key] || translations['en']?.[key] || key;
      for (const [param, value] of Object.entries(params)) {
        str = str.replace(`{${param}}`, value);
      }
      return str;
    }

    const wallStyles = [
      { color: "#27ae60", shadow: "#145a32", radius: "8px", texture: "none" },
      { color: "#39ff14", shadow: "#0f3d0f", radius: "12px", texture: "none" },
      { color: "#4CAF50", shadow: "#1B5E20", radius: "20px", texture: "none" },
      { color: "#bdbdbd", shadow: "#616161", radius: "2px", texture: "none" },
      { color: "#607d8b", shadow: "#263238", radius: "0px", texture: "none" },
      { color: "#ff9800", shadow: "#e65100", radius: "0px", texture: "linear-gradient(90deg, #ff9800 80%, #e65100 100%)" },
      { color: "#795548", shadow: "#3e2723", radius: "6px", texture: "repeating-linear-gradient(45deg, #8d6e63, #8d6e63 4px, #795548 4px, #795548 8px)" },
      { color: "#00bcd4", shadow: "#006064", radius: "50%", texture: "repeating-radial-gradient(circle, #00bcd4, #b2ebf2 10px)" },
      { color: "#9c27b0", shadow: "#4a148c", radius: "10px", texture: "repeating-linear-gradient(135deg, #9c27b0, #4a148c 10px)" },
      { color: "#e0f7fa", shadow: "#00bcd4", radius: "4px", texture: "repeating-linear-gradient(45deg, #e0f7fa, #b2ebf2 8px)" },
      { color: "#fbc02d", shadow: "#ff8f00", radius: "0px", texture: "repeating-linear-gradient(90deg, #fbc02d, #ffe082 10px)" },
      { color: "#789262", shadow: "#3e4d34", radius: "16px", texture: "none" },
      { color: "#757575", shadow: "#212121", radius: "0px", texture: "repeating-linear-gradient(135deg, #757575, #bdbdbd 10px)" },
      { color: "#00e676", shadow: "#00b248", radius: "50%", texture: "repeating-radial-gradient(circle, #00e676, #b2ff59 8px)" },
      { color: "#ffeb3b", shadow: "#fbc02d", radius: "20px", texture: "repeating-linear-gradient(45deg, #ffeb3b, #fff176 10px)" },
      { color: "#e91e63", shadow: "#880e4f", radius: "10px", texture: "repeating-linear-gradient(135deg, #e91e63, #f8bbd0 10px)" },
      { color: "#00bfae", shadow: "#00695c", radius: "50%", texture: "repeating-radial-gradient(circle, #00bfae, #1de9b6 8px)" },
    ];
    const mazeLayouts = [
      [
        "#.################.#",
        "#..F.....##........#",
        "#.##.###.##.###.##.#",
        "#.#..............#.#",
        "#.#.##.######.##.#.#",
        "#....*...##...*....#",
        "#.##.#.#.##.#.#.##.#",
        "#.#..............#.#",
        "#.#.##.######.##.#.#",
        ".............P......",
        "#.#.##.######.##.#.#",
        "#.#..............#.#",
        "#.##.#.#.##.#.#.##.#",
        "#....*...##...*....#",
        "#.#.##.######.##.#.#",
        "#.#..R...........#.#",
        "#.##.###.##.###.##.#",
        "#........##........#",
        "#.....########.....#",
        "#.################.#"
      ],
      [
        "#.################.#",
        "#.....########.....#",
        "#....*........F....#",
        "#.##..###..###.*##.#",
        "#.#....#....#....#.#",
        "#.#....#....#....#.#",
        "#...##........##.R.#",
        "###..#...##...#..###",
        "##.....######.....##",
        "#......*####.......#",
        "#...##...##...##...#",
        "##......####......##",
        "###..#.######.#..###",
        "#...##...##...##...#",
        "#.#....#..*.#....#.#",
        "#.#....#....#....#.#",
        "#.##..###..###..##.#",
        "#.....P............#",
        "#.....########.....#",
        "#.################.#"
      ],
      [
        "####################",
        "#..*..........F....#",
        "#.##.##..##..##.##.#",
        "#.##.##.####.##.##.#",
        "#........##........#",
        "#.##.#.######.#.##.#",
        "#....#...##...#..*.#",
        "####.###.##.###.####",
        "#...R..#....#......#",
        "#.####.#.##.#.####.#",
        "#.*..#........#....#",
        "##.#.##########.#.##",
        "#..#............#..#",
        "..##.###....###.##..",
        "#....#........#....#",
        "#.######.##.######.#",
        "#........##........#",
        "#*##.##.####.##.##.#",
        "#........P.........#",
        "####################"
      ],
      [
        "####################",
        "#.F................#",
        "#.#..#..####..#.*#.#",
        "#..##..######..##..#",
        "#.#..#...##...#..#.#",
        "#.##.###....###.##.#",
        "#....#...##...#R...#",
        "###*.##.####.##..###",
        "#.......#..#.......#",
        "#..####.#..#.####..#",
        "..........*.........",
        "##.##.#.####.#.##.##",
        "#..#............#..#",
        "#.##..##....##..##.#",
        "#...##........##...#",
        "#.######.##.######.#",
        "#..##....*.....##..#",
        "#.#..#.######.#..#.#",
        "#........P.........#",
        "####################"
      ]
    ];
    const COLLECTION_CANDLES = [
      { name: "Emerald", color: "#14F195", border: "#fff", effect: "pulse" },
      { name: "Sapphire", color: "#00BFFF", border: "#fff", effect: "spin" },
      { name: "Ruby", color: "#FF4500", border: "#fff", effect: "shake" },
      { name: "Amethyst", color: "#9945FF", border: "#fff", effect: "blink" },
      { name: "Topaz", color: "#FFD700", border: "#fff", effect: "glow" }
    ];
    let playerCollection = [];
    const gameBoard = document.getElementById('game-board');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const levelCompleteScreen = document.getElementById('level-complete');
    const finalScoreElement = document.getElementById('final-score');
    const finalLevelElement = document.getElementById('final-level');
    const completedLevelElement = document.getElementById('completed-level');
    const levelScoreElement = document.getElementById('level-score');
    const levelIndicator = document.getElementById('level-indicator');
    const restartBtn = document.getElementById('restart-btn');
    const abtnA = document.getElementById('abtn-a');
    let player;
    let ghosts = [];
    let candles = [];
    let walls = [];
    let bullets = [];
    let score = 0;
    let lives = 3;
    let level = 1;
    let gameRunning = false;
    let gameInterval;
    const CELL_SIZE = 15;
    const GRID_WIDTH = 20;
    const GRID_HEIGHT = 20;
    const PLAYER_SIZE = 15;
    const GHOST_SIZE = 15;
    const CANDLE_SIZE = 4;
    let BOARD_WIDTH = 300;
    let BOARD_HEIGHT = 300;
    let scaleX = 1;
    let scaleY = 1;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let powerMode = false;
    let powerModeTimeout = null;
    let playerMouthOpen = false;
    let playerMouthAnimTimer = 0;
    let playerDirection = { x: 0, y: 0 };
    let playerNextDirection = { x: 0, y: 0 };
    let playerX = 0;
    let playerY = 0;
    let playerStart = null;
    let ghostStarts = [];
    let powerCandleSpawned = false;
    let currentMazeLayout = null;

    function applyWallStyle(level) {
      const style = wallStyles[(level - 1) % wallStyles.length];
      document.documentElement.style.setProperty('--wall-color', style.color);
      document.documentElement.style.setProperty('--wall-radius', style.radius);
    }

    function adjustGameBoardSize() {
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      let maxBoardSize;
      if (window.matchMedia('(orientation: portrait)').matches) {
        maxBoardSize = Math.min(windowWidth - 20, windowHeight * 0.5);
      } else {
        maxBoardSize = Math.min(windowWidth * 0.6, windowHeight - 180);
      }
      BOARD_WIDTH = maxBoardSize;
      BOARD_HEIGHT = maxBoardSize;
      document.documentElement.style.setProperty('--board-size', `${maxBoardSize}px`);
      scaleX = maxBoardSize / 300;
      scaleY = maxBoardSize / 300;
      if (gameRunning && player) updateAllElementPositions();
    }

    function updateAllElementPositions() {
      player.style.left = (playerX * scaleX) + 'px';
      player.style.top = (playerY * scaleY) + 'px';
      player.style.transform = `scale(${scaleX}, ${scaleY}) rotate(${getPlayerRotation()}deg)`;
      ghosts.forEach(ghost => {
        ghost.element.style.left = (ghost.x * scaleX) + 'px';
        ghost.element.style.top = (ghost.y * scaleY) + 'px';
        ghost.element.style.transform = `scale(${scaleX}, ${scaleY})`;
      });
      candles.forEach(candle => {
        candle.element.style.left = (candle.x * scaleX) + 'px';
        candle.element.style.top = (candle.y * scaleY) + 'px';
        candle.element.style.transform = `scale(${scaleX}, ${scaleY})`;
      });
      walls.forEach(wall => {
        wall.element.style.left = (wall.x * scaleX) + 'px';
        wall.element.style.top = (wall.y * scaleY) + 'px';
        wall.element.style.width = (CELL_SIZE * scaleX) + 'px';
        wall.element.style.height = (CELL_SIZE * scaleY) + 'px';
      });
      bullets.forEach(b => {
        b.element.style.left = (b.x * scaleX) + 'px';
        b.element.style.top = (b.y * scaleY) + 'px';
      });
    }

    function getPlayerRotation() {
      if (playerDirection.x === 1) return 0;
      else if (playerDirection.x === -1) return 180;
      else if (playerDirection.y === -1) return 270;
      else if (playerDirection.y === 1) return 90;
      return 0;
    }

    function createPlayerSvg(mouthOpen = false) {
      return `
        <svg width="15" height="15" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg">
          <circle cx="7.5" cy="7.5" r="6" fill="#FFD6A5"/>
          <path d="M2 6C2 4 4 2.5 7.5 2.5C11 2.5 13 4 13 6H2Z" fill="#000"/>
          <path d="M6 2L7.5 1L9 2" fill="#000"/>
          <text x="6.5" y="6" font-size="2.5" fill="#14F195">S</text>
          <rect x="5" y="6" width="5" height="1.5" rx="0.5" fill="#FFF"/>
          ${mouthOpen
          ? `<path d="M5 9 Q7.5 13 10 9" stroke="#000" fill="#000" stroke-width="0.4"/>`
          : `<path d="M5 9 Q7.5 8.5 10 9" stroke="#000" fill="none" stroke-width="0.4"/>`
        }
        </svg>`;
    }

    function createGhostSvg(type) {
      let color, eyeColor, mouthPath;
      switch (type) {
        case 'fomo': color = '#FF0000'; eyeColor = '#FFF'; mouthPath = 'M5 10Q7.5 12 10 10'; break;
        case 'rug': color = '#FF69B4'; eyeColor = '#FFF'; mouthPath = 'M5 11Q7.5 9 10 11'; break;
        case 'volatility': color = '#00BFFF'; eyeColor = '#FFF'; mouthPath = 'M5 10L10 10'; break;
        case 'paper': color = '#FFA500'; eyeColor = '#FFF'; mouthPath = 'M5 11Q7.5 10 10 11'; break;
      }
      return `
        <svg width="15" height="15" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg">
          <path d="M1.5 7.5 
                   C1.5 4.5 3.5 1.5 7.5 1.5 
                   C11.5 1.5 13.5 4.5 13.5 7.5 
                   L13.5 12 
                   C13.5 12 12 10.5 11 12 
                   C10 13.5 9 12 8 12 
                   C7 12 6 13.5 5 12 
                   C4 10.5 3 12 3 12 
                   L1.5 7.5Z"
            fill="${color}" />
          <circle cx="5" cy="6" r="1" fill="${eyeColor}" />
          <circle cx="10" cy="6" r="1" fill="${eyeColor}" />
          <circle cx="5" cy="6" r="0.5" fill="#000" />
          <circle cx="10" cy="6" r="0.5" fill="#000" />
          <path d="${mouthPath}" stroke="#000" fill="none" stroke-width="0.4" />
        </svg>`;
    }

    function createMaze(levelIndex) {
      playerStart = null;
      ghostStarts = [];
      currentMazeLayout = mazeLayouts[levelIndex] || mazeLayouts[0];
      const layout = currentMazeLayout;
      for (let y = 0; y < layout.length; y++) {
        for (let x = 0; x < layout[y].length; x++) {
          const cell = layout[y][x];
          if (cell === '#') {
            const wall = document.createElement('div');
            wall.className = 'wall';
            wall.style.left = (x * CELL_SIZE * scaleX) + 'px';
            wall.style.top = (y * CELL_SIZE * scaleY) + 'px';
            wall.style.width = (CELL_SIZE * scaleX) + 'px';
            wall.style.height = (CELL_SIZE * scaleY) + 'px';
            gameBoard.appendChild(wall);
            walls.push({
              x: x * CELL_SIZE,
              y: y * CELL_SIZE,
              width: CELL_SIZE,
              height: CELL_SIZE,
              element: wall
            });
          } else if (cell === '.') {
            const cx = x * CELL_SIZE + (CELL_SIZE - CANDLE_SIZE) / 2;
            const cy = y * CELL_SIZE + (CELL_SIZE - CANDLE_SIZE) / 2;
            createCandleAt(cx, cy);
          } else if (cell === '*') {
            const cx = x * CELL_SIZE + (CELL_SIZE - 10) / 2;
            const cy = y * CELL_SIZE + (CELL_SIZE - 10) / 2;
            createPowerCandleAt(cx, cy);
          } else if (cell === 'P') {
            playerStart = {
              x: x * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2,
              y: y * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2
            };
          } else if (cell === 'F' || cell === 'R' || cell === 'V' || cell === 'A') {
            ghostStarts.push({
              type: cell,
              x: x * CELL_SIZE + (CELL_SIZE - GHOST_SIZE) / 2,
              y: y * CELL_SIZE + (CELL_SIZE - GHOST_SIZE) / 2
            });
          }
        }
      }
    }

    function getRandomCorridorCell() {
      const freeCells = [];
      for (let y = 0; y < currentMazeLayout.length; y++) {
        for (let x = 0; x < currentMazeLayout[y].length; x++) {
          const cell = currentMazeLayout[y][x];
          if (cell === '.' || cell === ' ' || cell === '*') {
            freeCells.push({ x, y });
          }
        }
      }
      if (freeCells.length === 0) return { x: 10, y: 10 };
      return freeCells[Math.floor(Math.random() * freeCells.length)];
    }

    function createCandleAt(x, y, color = null) {
      for (const candle of candles) {
        const dx = candle.x - x;
        const dy = candle.y - y;
        if (Math.hypot(dx, dy) < 10) return;
      }
      const candle = document.createElement('div');
      candle.className = 'candle';
      if (color) {
        if (color === "blue") candle.style.background = "#00BFFF";
        if (color === "green") candle.style.background = "#14F195";
        if (color === "red") candle.style.background = "#FF4500";
        if (color === "yellow") candle.style.background = "#FFD700";
        if (color === "purple") candle.style.background = "#9945FF";
        if (color === "gold") candle.style.background = "#FFD700";
      }
      candle.style.left = (x * scaleX) + 'px';
      candle.style.top = (y * scaleY) + 'px';
      gameBoard.appendChild(candle);
      candles.push({
        element: candle,
        x: x,
        y: y
      });
    }

    function createPowerCandleAt(x, y) {
      const candle = document.createElement('div');
      candle.className = 'candle power-candle';
      candle.style.left = (x * scaleX) + 'px';
      candle.style.top = (y * scaleY) + 'px';
      gameBoard.appendChild(candle);
      candles.push({
        element: candle,
        x: x,
        y: y,
        power: true
      });
    }

    function spawnPowerCandleOncePerLevel() {
      if (powerCandleSpawned) return;
      powerCandleSpawned = true;
      let isCollection = Math.random() < 0.5;
      let candleData = null;
      if (isCollection) {
        let notCollected = COLLECTION_CANDLES.filter(c => !playerCollection.includes(c.name));
        if (notCollected.length === 0) notCollected = COLLECTION_CANDLES;
        candleData = notCollected[Math.floor(Math.random() * notCollected.length)];
      }
      const cell = getRandomCorridorCell();
      const x = cell.x * CELL_SIZE + (CELL_SIZE - 10) / 2;
      const y = cell.y * CELL_SIZE + (CELL_SIZE - 10) / 2;
      const candle = document.createElement('div');
      candle.className = 'candle power-candle big-candle';
      candle.style.left = (x * scaleX) + 'px';
      candle.style.top = (y * scaleY) + 'px';
      candle.style.width = '10px';
      candle.style.height = '10px';
      candle.style.transform = `scale(${scaleX}, ${scaleY})`;
      if (isCollection && candleData) {
        candle.classList.add('candle-' + candleData.effect);
        candle.style.background = candleData.color;
        candle.style.border = `2px solid ${candleData.border}`;
        candle.dataset.collection = candleData.name;
      }
      gameBoard.appendChild(candle);
      candles.push({
        element: candle,
        x: x,
        y: y,
        power: true,
        big: true,
        collection: isCollection ? candleData.name : null
      });
      const popupText = isCollection && candleData ?
        getTranslation('fomoPopupCollect', { name: candleData.name }) :
        getTranslation('fomoPopupBigCandle');
      showFomoPopup(popupText);

      let timer = 10;
      showFomoTimer(timer);
      const timerInterval = setInterval(() => {
        timer--;
        updateFomoTimer(timer);
        if (timer <= 0) {
          clearInterval(timerInterval);
          if (gameBoard.contains(candle)) {
            gameBoard.removeChild(candle);
            candles = candles.filter(c => c.element !== candle);
            const missedText = isCollection && candleData ?
              getTranslation('fomoPopupMissedCollection') :
              getTranslation('fomoPopupMissedBig');
            showFomoPopup(missedText);
            hideFomoTimer();
          }
        }
      }, 1000);
    }

    function showFomoPopup(text) {
      let popup = document.getElementById('fomo-popup');
      if (!popup) return;
      popup.innerHTML = text;
      popup.style.display = 'flex';
      popup.style.animation = 'fomo-fadein 0.4s';
      setTimeout(() => {
        if (popup) popup.style.display = 'none';
      }, 4000);
    }

    function showFomoTimer(seconds) {
      let timerDiv = document.getElementById('fomo-timer');
      if (!timerDiv) {
        timerDiv = document.createElement('div');
        timerDiv.id = 'fomo-timer';
        timerDiv.className = 'fomo-timer';
        timerDiv.style.display = 'none';
        gameBoard.appendChild(timerDiv);
      }
      timerDiv.textContent = getTranslation('fomoTimer', { seconds: seconds });
      timerDiv.style.display = 'block';
      timerDiv.classList.remove('fomo-blink');
      if (seconds <= 3) timerDiv.classList.add('fomo-blink');
    }

    function updateFomoTimer(seconds) {
      const timerDiv = document.getElementById('fomo-timer');
      if (timerDiv) {
        timerDiv.textContent = getTranslation('fomoTimer', { seconds: seconds });
        if (seconds <= 3) timerDiv.classList.add('fomo-blink');
        else timerDiv.classList.remove('fomo-blink');
      }
    }

    function hideFomoTimer() {
      const timerDiv = document.getElementById('fomo-timer');
      if (timerDiv) {
        timerDiv.style.display = 'none';
        timerDiv.classList.remove('fomo-blink');
      }
    }

    function createGhosts() {
      ghosts = [];
      ghostStarts.forEach(ghostData => {
        const ghost = document.createElement('div');
        let type;
        switch (ghostData.type) {
          case 'F': type = 'fomo'; break;
          case 'R': type = 'rug'; break;
          case 'V': type = 'volatility'; break;
          case 'A': type = 'paper'; break;
        }
        ghost.className = 'ghost ghost-' + type;
        ghost.style.left = (ghostData.x * scaleX) + 'px';
        ghost.style.top = (ghostData.y * scaleY) + 'px';
        ghost.style.transform = `scale(${scaleX}, ${scaleY})`;
        ghost.innerHTML = createGhostSvg(type);
        gameBoard.appendChild(ghost);
        ghosts.push({
          element: ghost,
          x: ghostData.x,
          y: ghostData.y,
          type: type,
          speed: 1,
          direction: { x: 0, y: 0 },
          nextDirection: { x: 0, y: 0 }
        });
      });
    }

    function createPlayer() {
      player = document.createElement('div');
      player.className = 'player';
      player.style.left = (playerX * scaleX) + 'px';
      player.style.top = (playerY * scaleY) + 'px';
      player.style.transform = `scale(${scaleX}, ${scaleY})`;
      player.innerHTML = createPlayerSvg();
      player.speed = 1.5;
      player.invincible = false;
      player.lastShot = 0;
      gameBoard.appendChild(player);
    }

    function findValidPosition(width, height) {
      let x, y, isValid;
      let attempts = 0;
      const maxAttempts = 100;
      const minDistanceFromPlayer = 30;
      const minDistanceFromCandles = 15;
      do {
        isValid = true;
        const gridX = Math.floor(Math.random() * GRID_WIDTH);
        const gridY = Math.floor(Math.random() * GRID_HEIGHT);
        x = gridX * CELL_SIZE + (CELL_SIZE - width) / 2;
        y = gridY * CELL_SIZE + (CELL_SIZE - height) / 2;
        for (const wall of walls) {
          if (
            x < wall.x + wall.width &&
            x + width > wall.x &&
            y < wall.y + wall.height &&
            y + height > wall.y
          ) {
            isValid = false;
            break;
          }
        }
        if (isValid && Math.hypot(x - playerX, y - playerY) < minDistanceFromPlayer) {
          isValid = false;
        }
        if (isValid) {
          for (const c of candles) {
            if (Math.hypot(x - c.x, y - c.y) < minDistanceFromCandles) {
              isValid = false;
              break;
            }
          }
        }
        attempts++;
        if (attempts >= maxAttempts) {
          isValid = true;
        }
      } while (!isValid);
      return { x, y };
    }

    function updateCollectionProfile() {
      const profile = document.getElementById('collection-profile');
      if (!profile) return;
      let html = `<span class="collection-label">${getTranslation('collectionLabel')}</span>`;
      COLLECTION_CANDLES.forEach(c => {
        const collected = playerCollection.includes(c.name);
        html += `<span class="candle-icon${collected ? ' collected' : ''}" 
            style="background:${c.color};${c.effect === 'glow' ? 'box-shadow:0 0 12px #FFD700;' : ''}"
            title="${c.name}"></span>`;
      });
      if (playerCollection.length === COLLECTION_CANDLES.length) {
        html += `<span style="margin-left:8px;color:#14F195;font-weight:bold;">‚úî</span>`;
      }
      profile.innerHTML = html;
    }

    function initGame() {
      applyWallStyle(1);
      const elementsToKeep = [startScreen, gameOverScreen, levelCompleteScreen, levelIndicator];
      const children = Array.from(gameBoard.children);
      for (const child of children) {
        if (!elementsToKeep.includes(child)) gameBoard.removeChild(child);
      }
      score = 0;
      lives = 3;
      level = 1;
      scoreElement.textContent = score;
      livesElement.textContent = lives;
      levelIndicator.innerHTML = `<span data-translate-key="levelLabel">${getTranslation('levelLabel')}</span> 1`;
      ghosts = [];
      candles = [];
      walls = [];
      bullets.forEach(b => {
        if (gameBoard.contains(b.element)) {
          gameBoard.removeChild(b.element);
        }
      });
      bullets = [];
      powerMode = false;
      showAButton(false);
      if (powerModeTimeout) clearTimeout(powerModeTimeout);
      powerCandleSpawned = false;
      playerCollection = [];
      updateCollectionProfile();
      createMaze(0);
      playerX = playerStart ? playerStart.x : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
      playerY = playerStart ? playerStart.y : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
      playerDirection = { x: 0, y: 0 };
      playerNextDirection = { x: 0, y: 0 };
      createPlayer();
      createGhosts();
      createCandles();
      generateAndShowQuest();
    }

    function startGame() {
      if (gameRunning) return;
      gameRunning = true;
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      levelCompleteScreen.style.display = 'none';
      gameInterval = setInterval(gameLoop, 30);
      setTimeout(spawnPowerCandleOncePerLevel, 3000);
    }

    function gameLoop() {
      playerMouthAnimTimer++;
      if (playerMouthAnimTimer > 6) {
        playerMouthOpen = !playerMouthOpen;
        playerMouthAnimTimer = 0;
        player.innerHTML = createPlayerSvg(playerMouthOpen);
      }
      if (playerNextDirection.x !== 0 || playerNextDirection.y !== 0) {
        if (canMove(playerX, playerY, playerNextDirection, PLAYER_SIZE)) {
          playerDirection = { ...playerNextDirection };
        }
      }
      if (playerDirection.x !== 0 || playerDirection.y !== 0) {
        const speed = player.speed || 1.5;
        const nextX = playerX + playerDirection.x * speed;
        const nextY = playerY + playerDirection.y * speed;
        if (canMove(playerX, playerY, playerDirection, PLAYER_SIZE)) {
          playerX = nextX;
          playerY = nextY;
          handleTunnels();
          player.style.left = (playerX * scaleX) + 'px';
          player.style.top = (playerY * scaleY) + 'px';
          player.style.transform = `scale(${scaleX}, ${scaleY}) rotate(${getPlayerRotation()}deg)`;
        }
      }
      moveGhosts();
      moveBullets();
      checkCandleCollection();
      checkGhostCollision();
    }

    function handleTunnels() {
      if (playerX < -PLAYER_SIZE) playerX = 300;
      else if (playerX > 300) playerX = -PLAYER_SIZE;
      if (playerY < -PLAYER_SIZE) playerY = 300;
      else if (playerY > 300) playerY = -PLAYER_SIZE;
      ghosts.forEach(ghost => {
        if (ghost.x < -GHOST_SIZE) ghost.x = 300;
        else if (ghost.x > 300) ghost.x = -GHOST_SIZE;
        if (ghost.y < -GHOST_SIZE) ghost.y = 300;
        else if (ghost.y > 300) ghost.y = -GHOST_SIZE;
        ghost.element.style.left = (ghost.x * scaleX) + 'px';
        ghost.element.style.top = (ghost.y * scaleY) + 'px';
      });
    }

    function canMove(x, y, dir, size) {
      const nextX = x + dir.x * 1;
      const nextY = y + dir.y * 1;
      if (nextX < 0 || nextX > 300 || nextY < 0 || nextY > 300) return true;
      for (const wall of walls) {
        if (
          nextX < wall.x + wall.width &&
          nextX + size > wall.x &&
          nextY < wall.y + wall.height &&
          nextY + size > wall.y
        ) {
          return false;
        }
      }
      return true;
    }

    function moveGhosts() {
      ghosts.forEach(ghost => {
        if (Math.random() < 0.05) {
          let dx = playerX - ghost.x;
          let dy = playerY - ghost.y;
          if (Math.abs(dx) > 150) dx = -Math.sign(dx) * (300 - Math.abs(dx));
          if (Math.abs(dy) > 150) dy = -Math.sign(dy) * (300 - Math.abs(dy));
          ghost.nextDirection = Math.abs(dx) > Math.abs(dy) ? { x: Math.sign(dx), y: 0 } : { x: 0, y: Math.sign(dy) };
        }
        if (ghost.nextDirection.x !== 0 || ghost.nextDirection.y !== 0) {
          if (canMove(ghost.x, ghost.y, ghost.nextDirection, GHOST_SIZE)) {
            ghost.direction = { ...ghost.nextDirection };
            ghost.nextDirection = { x: 0, y: 0 };
          }
        }
        if (!canMove(ghost.x, ghost.y, ghost.direction, GHOST_SIZE)) {
          const directions = [
            { x: 1, y: 0 },
            { x: -1, y: 0 },
            { x: 0, y: 1 },
            { x: 0, y: -1 }
          ];
          for (let i = directions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [directions[i], directions[j]] = [directions[j], directions[i]];
          }
          for (const dir of directions) {
            if (canMove(ghost.x, ghost.y, dir, GHOST_SIZE)) {
              ghost.direction = dir;
              break;
            }
          }
        }
        ghost.x += ghost.direction.x * ghost.speed;
        ghost.y += ghost.direction.y * ghost.speed;
        ghost.element.style.left = (ghost.x * scaleX) + 'px';
        ghost.element.style.top = (ghost.y * scaleY) + 'px';
      });
    }

    function shootBullet() {
      if (!powerMode) return;
      if (player.lastShot && Date.now() - player.lastShot < 300) return;
      player.lastShot = Date.now();
      const bullet = document.createElement('div');
      bullet.className = 'bullet';
      bullet.style.left = (playerX + PLAYER_SIZE / 2 - 3) * scaleX + 'px';
      bullet.style.top = (playerY + PLAYER_SIZE / 2 - 3) * scaleY + 'px';
      gameBoard.appendChild(bullet);
      let dir = { ...playerDirection };
      if (dir.x === 0 && dir.y === 0) dir = { x: 1, y: 0 };
      bullets.push({
        element: bullet,
        x: playerX + PLAYER_SIZE / 2 - 3,
        y: playerY + PLAYER_SIZE / 2 - 3,
        dir: dir,
        speed: 5
      });
      playTone(1000, 0.05, "square", 0.12);
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.dir.x * b.speed;
        b.y += b.dir.y * b.speed;
        b.element.style.left = (b.x * scaleX) + 'px';
        b.element.style.top = (b.y * scaleY) + 'px';
        if (b.x < 0 || b.x > 300 || b.y < 0 || b.y > 300) {
          if (gameBoard.contains(b.element)) {
            gameBoard.removeChild(b.element);
          }
          bullets.splice(i, 1);
          continue;
        }
        for (let j = ghosts.length - 1; j >= 0; j--) {
          const g = ghosts[j];
          const dx = b.x + 3 - (g.x + GHOST_SIZE / 2);
          const dy = b.y + 3 - (g.y + GHOST_SIZE / 2);
          if (Math.hypot(dx, dy) < 10) {
            if (gameBoard.contains(g.element)) {
              gameBoard.removeChild(g.element);
            }
            ghosts.splice(j, 1);
            if (gameBoard.contains(b.element)) {
              gameBoard.removeChild(b.element);
            }
            bullets.splice(i, 1);
            lives++;
            livesElement.textContent = lives;
            playTone(1200, 0.1, "square", 0.2);
            break;
          }
        }
      }
    }

    function checkCandleCollection() {
      for (let i = candles.length - 1; i >= 0; i--) {
        const candle = candles[i];
        const size = candle.power ? (candle.big ? 10 : 10) : 4;
        const dx = playerX + 7.5 - candle.x - size / 2;
        const dy = playerY + 7.5 - candle.y - size / 2;
        const distance = Math.hypot(dx, dy);
        if (distance < 7.5 + size / 2) {
          if (gameBoard.contains(candle.element)) {
            gameBoard.removeChild(candle.element);
          }
          candles.splice(i, 1);
          if (candle.big) {
            if (candle.collection) {
              if (!playerCollection.includes(candle.collection)) {
                playerCollection.push(candle.collection);
                showFomoPopup(getTranslation('collectedNew'));
                updateCollectionProfile();
              } else {
                showFomoPopup(getTranslation('collectedAgain'));
              }
              playBigCandleSound();
              hideFomoTimer();
            } else {
              score += 100;
              scoreElement.textContent = score;
              playBigCandleSound();
              showFomoPopup(getTranslation('bigCandleBonus'));
              hideFomoTimer();
            }
          } else if (candle.power) {
            playPowerCandleSound();
            activatePowerMode();
          } else {
            playCandleSound();
            score += 10;
            scoreElement.textContent = score;
          }
          if (candles.filter(c => !c.big && !c.power).length === 0) levelComplete();
        }
      }
    }

    function createCandles() {
      let count = 0;
      for (let i = 0; i < candles.length; i++) {
        if (!candles[i].power && !candles[i].big) count++;
      }
      let minCandles = 10 + 5 * level;
      let candleColor = null;
      if (questParams && questParams.count && questParams.color) {
        minCandles = questParams.count;
        candleColor = questParams.color;
      }
      for (let i = count; i < minCandles; i++) {
        const validPos = findValidPosition(CANDLE_SIZE, CANDLE_SIZE);
        createCandleAt(validPos.x, validPos.y, candleColor);
      }
    }

    function activatePowerMode() {
      if (powerModeTimeout) clearTimeout(powerModeTimeout);
      powerMode = true;
      player.style.filter = 'drop-shadow(0 0 10px #00FFFA) brightness(1.5)';
      player.invincible = true;
      ghosts.forEach(g => g.element.style.filter = 'grayscale(1) brightness(1.5)');
      showAButton(true);
      powerModeTimeout = setTimeout(() => {
        powerMode = false;
        player.style.filter = '';
        player.invincible = false;
        ghosts.forEach(g => g.element.style.filter = '');
        showAButton(false);
      }, 5000);
    }

    function checkGhostCollision() {
      for (const ghost of ghosts) {
        const dx = playerX + PLAYER_SIZE / 2 - ghost.x - GHOST_SIZE / 2;
        const dy = playerY + PLAYER_SIZE / 2 - ghost.y - GHOST_SIZE / 2;
        const distance = Math.hypot(dx, dy);
        if (distance < 10) {
          if (powerMode) {
            if (gameBoard.contains(ghost.element)) {
              gameBoard.removeChild(ghost.element);
            }
            ghosts = ghosts.filter(g => g.element !== ghost.element);
            score += 100;
            scoreElement.textContent = score;
          } else if (player.invincible) { } else {
            playerDies();
          }
        }
      }
    }

    function playerDies() {
      lives--;
      livesElement.textContent = lives;
      playDeathSound();
      player.classList.add('death-anim');
      clearInterval(gameInterval);
      setTimeout(() => {
        player.classList.remove('death-anim');
        if (lives <= 0) gameOver();
        else {
          playerX = playerStart ? playerStart.x : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
          playerY = playerStart ? playerStart.y : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
          playerDirection = { x: 0, y: 0 };
          playerNextDirection = { x: 0, y: 0 };
          player.style.left = (playerX * scaleX) + 'px';
          player.style.top = (playerY * scaleY) + 'px';
          player.style.transform = `scale(${scaleX}, ${scaleY})`;
          gameInterval = setInterval(gameLoop, 30);
        }
      }, 800);
    }

    function levelComplete() {
      clearInterval(gameInterval);
      gameRunning = false;
      player.classList.add('win-anim');
      playLevelSound();
      completedLevelElement.textContent = level;
      levelScoreElement.textContent = score;
      levelCompleteScreen.style.display = 'flex';
      level++;
      setTimeout(() => {
        player.classList.remove('win-anim');
        levelCompleteScreen.style.display = 'none';
        applyWallStyle(level);
        const elementsToKeep = [startScreen, gameOverScreen, levelCompleteScreen, levelIndicator];
        const children = Array.from(gameBoard.children);
        for (const child of children) {
          if (!elementsToKeep.includes(child)) gameBoard.removeChild(child);
        }
        ghosts = [];
        candles = [];
        walls = [];
        bullets.forEach(b => {
          if (gameBoard.contains(b.element)) {
            gameBoard.removeChild(b.element);
          }
        });
        bullets = [];
        powerMode = false;
        showAButton(false);
        if (powerModeTimeout) clearTimeout(powerModeTimeout);
        powerCandleSpawned = false;
        levelIndicator.innerHTML = `<span data-translate-key="levelLabel">${getTranslation('levelLabel')}</span> ${level}`;
        createMaze((level - 1) % mazeLayouts.length);
        playerX = playerStart ? playerStart.x : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
        playerY = playerStart ? playerStart.y : 10 * CELL_SIZE + (CELL_SIZE - PLAYER_SIZE) / 2;
        player = document.createElement('div');
        player.className = 'player';
        player.style.left = (playerX * scaleX) + 'px';
        player.style.top = (playerY * scaleY) + 'px';
        player.style.transform = `scale(${scaleX}, ${scaleY})`;
        player.innerHTML = createPlayerSvg();
        player.speed = 1.5;
        player.invincible = false;
        player.lastShot = 0;
        gameBoard.appendChild(player);
        createGhosts();
        createCandles();
        startGame();
      }, 1200);
    }

    function gameOver() {
      clearInterval(gameInterval);
      gameRunning = false;
      finalScoreElement.textContent = score;
      finalLevelElement.textContent = level;
      gameOverScreen.style.display = 'flex';
    }

    function showAButton(active) {
      if (active) abtnA.classList.add('active');
      else abtnA.classList.remove('active');
    }

    // --- Lottery Logic ---
    setInterval(() => {
      let prizeElem = document.getElementById('prize-amount');
      if (!prizeElem) return;
      let current = parseInt(prizeElem.textContent.replace(/\D/g, '')) || 4200;
      let next = current + Math.floor(Math.random() * 5);
      prizeElem.textContent = '$' + next.toLocaleString();
    }, 3000);

    document.getElementById('show-rules-btn').onclick = function () {
      document.getElementById('lottery-modal-text').innerHTML = getTranslation('lotteryRules');
      document.getElementById('lottery-modal').style.display = 'flex';
    };
    document.getElementById('modal-buy-ticket-btn').onclick = function () {
      document.getElementById('lottery-modal-text').innerHTML = getTranslation('ticketPurchased');
      setTimeout(() => {
        document.getElementById('lottery-modal').style.display = 'none';
        document.getElementById('lottery-intro').style.display = 'none';
      }, 1800);
    };
    document.getElementById('modal-skip-btn').onclick = function () {
      document.getElementById('lottery-modal').style.display = 'none';
      document.getElementById('lottery-intro').style.display = 'none';
    };
    document.getElementById('buy-ticket-btn').onclick = function () {
      document.getElementById('lottery-details').style.display = 'block';
      document.getElementById('lottery-details').innerHTML = getTranslation('ticketPurchased');
      setTimeout(() => {
        document.getElementById('lottery-intro').style.display = 'none';
      }, 1800);
    };
    document.getElementById('skip-lottery-btn').onclick = function () {
      document.getElementById('lottery-intro').style.display = 'none';
    };

    // --- Language Switcher Logic ---
    const langSelect = document.getElementById('lang-select');
    const langIcon = document.getElementById('lang-icon');

    langSelect.addEventListener('change', function () {
      currentLang = this.value;
      langSelect.style.display = 'none';
      langIcon.style.display = 'inline-block';
      translateUI();
      generateAndShowQuest();
    });

    langIcon.addEventListener('click', function () {
      langSelect.style.display = 'inline-block';
      langIcon.style.display = 'none';
      langSelect.focus();
    });

    // --- Gemini Quest Generation ---
    async function fetchQuestFromGemini() {
      const prompt = getTranslation('questPrompt');
      try {
        const response = await fetch("https://vercel-gemini-proxy-yuricks-projects.vercel.app/api/gemini", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }]
          })
        });
        const data = await response.json();
        let quest = data.candidates?.[0]?.content?.parts?.[0]?.text || getTranslation('questDefaultFallback');
        quest = quest.replace(/^[\s\n\r]+|[\s\n\r]+$/g, '').replace(/^["']|["']$/g, '');
        return quest;
      } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–≤–µ—Å—Ç–∞:", e);
        return getTranslation('questFetchError');
      }
    }
    function parseQuest(quest) {
      const result = { count: null, color: null };
      const countMatch = quest.match(/(\d+)\s/);
      if (countMatch) result.count = parseInt(countMatch[1]);

      const colors = {
        "–∑–µ–ª—ë–Ω—ã—Ö": "green", "—Å–∏–Ω–∏—Ö": "blue", "–∫—Ä–∞—Å–Ω—ã—Ö": "red", "–∂—ë–ª—Ç—ã—Ö": "yellow", "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã—Ö": "purple", "–∑–æ–ª–æ—Ç—ã—Ö": "gold",
        "green": "green", "blue": "blue", "red": "red", "yellow": "yellow", "purple": "purple", "gold": "gold",
        "verde": "green", "azul": "blue", "roja": "red", "amarilla": "yellow", "p√∫rpura": "purple", "dorada": "gold",
        "gr√ºne": "green", "blaue": "blue", "rote": "red", "gelbe": "yellow", "lila": "purple", "goldene": "gold",
        "verte": "green", "bleue": "blue", "rouge": "red", "jaune": "yellow", "violette": "purple", "dor√©e": "gold",
        "verde": "green", "blu": "blue", "rossa": "red", "gialla": "yellow", "viola": "purple", "dorata": "gold",
        "ÁªøËâ≤": "green", "ËìùËâ≤": "blue", "Á∫¢Ëâ≤": "red", "ÈªÑËâ≤": "yellow", "Á¥´Ëâ≤": "purple", "ÈáëËâ≤": "gold",
        "–∑–µ–ª–µ–Ω–∏—Ö": "green", "—Å–∏–Ω—ñ—Ö": "blue", "—á–µ—Ä–≤–æ–Ω–∏—Ö": "red", "–∂–æ–≤—Ç–∏—Ö": "yellow", "—Ñ—ñ–æ–ª–µ—Ç–æ–≤–∏—Ö": "purple", "–∑–æ–ª–æ—Ç–∏—Ö": "gold"
      };
      for (const [word, color] of Object.entries(colors)) {
        if (quest.toLowerCase().includes(word.toLowerCase())) {
          result.color = color;
          break;
        }
      }
      return result;
    }
    let currentQuest = "";
    let questParams = {};
    function showQuest(quest) {
      currentQuest = quest;
      const questLabel = getTranslation('questLabel');
      document.getElementById('console-quest').textContent = questLabel + ": " + quest;
    }
    async function generateAndShowQuest() {
      showQuest(getTranslation('generatingQuest'));
      const quest = await fetchQuestFromGemini();
      showQuest(quest);
      questParams = parseQuest(quest);
    }

    document.addEventListener('DOMContentLoaded', () => {
      startBtn.addEventListener('click', () => {

        // --- –ü—Ä–æ–º–µ—Ç–µ–π: –ü—Ä–æ—Ç–æ–∫–æ–ª "–ü–µ—Ä–≤—ã–π –ö–æ–Ω—Ç–∞–∫—Ç" ---
        const userData = window.Telegram?.WebApp?.initDataUnsafe?.user;
        if (userData) {
          console.log('–ü—Ä–æ–º–µ—Ç–µ–π: –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å. ID:', userData.id, '–ò–º—è:', userData.first_name, '. –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞...');
          fetch('/api/user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id: userData.id,
              first_name: userData.first_name,
            }),
          })
            .then(response => response.json())
            .then(data => console.log('–ü—Ä–æ–º–µ—Ç–µ–π: –û—Ç–≤–µ—Ç –æ—Ç –≤—Ä–∞—Ç:', data.message))
            .catch(error => console.error('–ü—Ä–æ–º–µ—Ç–µ–π: –û—à–∏–±–∫–∞ —Å–∏–≥–Ω–∞–ª–∞!', error));
        } else {
          console.log('–ü—Ä–æ–º–µ—Ç–µ–π: –°—Ä–µ–¥–∞ Telegram –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É—é —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–∏–∑—Ä–∞–∫–∞.');
          fetch('/api/user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id: 987654321,
              first_name: 'BrowserGhost',
            }),
          })
            .then(response => response.json())
            .then(data => console.log('–ü—Ä–æ–º–µ—Ç–µ–π: –û—Ç–≤–µ—Ç –æ—Ç –≤—Ä–∞—Ç:', data.message))
            .catch(error => console.error('–ü—Ä–æ–º–µ—Ç–µ–π: –û—à–∏–±–∫–∞ —Å–∏–≥–Ω–∞–ª–∞!', error));
        }
        // --- –ö–æ–Ω–µ—Ü –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ ---

        initGame();
        startGame();
      });

      restartBtn.addEventListener('click', () => {
        initGame();
        startGame();
      });

      // --- Initialize Language and UI ---
      const browserLang = navigator.language.slice(0, 2);
      if (Object.keys(translations).includes(browserLang)) {
        currentLang = browserLang;
        langSelect.value = browserLang;
      }
      langSelect.style.display = 'inline-block';
      langIcon.style.display = 'none';

      translateUI(); // Initial translation on page load
      adjustGameBoardSize();
    });

    document.addEventListener('keydown', e => {
      if (!gameRunning) return;
      switch (e.key) {
        case 'ArrowUp': case 'w': case 'W': playerNextDirection = { x: 0, y: -1 }; break;
        case 'ArrowDown': case 's': case 'S': playerNextDirection = { x: 0, y: 1 }; break;
        case 'ArrowLeft': case 'a': case 'A': playerNextDirection = { x: -1, y: 0 }; break;
        case 'ArrowRight': case 'd': case 'D': playerNextDirection = { x: 1, y: 0 }; break;
        case ' ': case 'j': case 'J': shootBullet(); break;
      }
      if (playerDirection.x === 0 && playerDirection.y === 0) {
        playerDirection = { ...playerNextDirection };
      }
    });
    window.addEventListener('resize', adjustGameBoardSize);
    window.addEventListener('orientationchange', () => setTimeout(adjustGameBoardSize, 200));

    // --- Joystick (Brawl Stars style) ---
    const joystickOuter = document.getElementById('joystick-outer');
    const joystickStick = document.getElementById('joystick-stick');
    let joystickActive = false;
    let joystickDir = { x: 0, y: 0 };
    let joystickTimer = null;
    function setJoystickDir(x, y) {
      const maxDist = joystickOuter.offsetWidth / 2 - joystickStick.offsetWidth / 2;
      let dist = Math.sqrt(x * x + y * y);
      if (dist > maxDist) {
        x = x * maxDist / dist;
        y = y * maxDist / dist;
        dist = maxDist;
      }
      joystickStick.style.left = (joystickOuter.offsetWidth / 2 - joystickStick.offsetWidth / 2 + x) + 'px';
      joystickStick.style.top = (joystickOuter.offsetHeight / 2 - joystickStick.offsetHeight / 2 + y) + 'px';
      if (dist > 10) {
        let nx = x / dist, ny = y / dist;
        if (Math.abs(nx) > Math.abs(ny)) {
          joystickDir = { x: Math.sign(nx), y: 0 };
        } else {
          joystickDir = { x: 0, y: Math.sign(ny) };
        }
      } else {
        joystickDir = { x: 0, y: 0 };
      }
    }
    function resetJoystick() {
      joystickStick.style.left = (joystickOuter.offsetWidth / 2 - joystickStick.offsetWidth / 2) + 'px';
      joystickStick.style.top = (joystickOuter.offsetHeight / 2 - joystickStick.offsetHeight / 2) + 'px';
      joystickDir = { x: 0, y: 0 };
    }
    function joystickLoop() {
      if (joystickActive) {
        playerNextDirection = { ...joystickDir };
        joystickTimer = requestAnimationFrame(joystickLoop);
      }
    }
    // Touch events
    joystickOuter.addEventListener('touchstart', function (e) {
      if (e.touches.length === 1) {
        joystickActive = true;
        joystickLoop();
      }
    });
    joystickOuter.addEventListener('touchmove', function (e) {
      if (joystickActive && e.touches.length === 1) {
        const rect = joystickOuter.getBoundingClientRect();
        const dx = e.touches[0].clientX - (rect.left + joystickOuter.offsetWidth / 2);
        const dy = e.touches[0].clientY - (rect.top + joystickOuter.offsetHeight / 2);
        setJoystickDir(dx, dy);
      }
    });
    joystickOuter.addEventListener('touchend', function (e) {
      joystickActive = false;
      resetJoystick();
      cancelAnimationFrame(joystickTimer);
      playerNextDirection = { x: 0, y: 0 };
    });
    // Mouse events (for desktop)
    joystickOuter.addEventListener('mousedown', function (e) {
      if (e.button === 0) {
        joystickActive = true;
        joystickLoop();
      }
    });
    joystickOuter.addEventListener('mousemove', function (e) {
      if (joystickActive) {
        const rect = joystickOuter.getBoundingClientRect();
        const dx = e.clientX - (rect.left + joystickOuter.offsetWidth / 2);
        const dy = e.clientY - (rect.top + joystickOuter.offsetHeight / 2);
        setJoystickDir(dx, dy);
      }
    });
    joystickOuter.addEventListener('mouseup', function (e) {
      joystickActive = false;
      resetJoystick();
      cancelAnimationFrame(joystickTimer);
      playerNextDirection = { x: 0, y: 0 };
    });
    joystickOuter.addEventListener('mouseleave', function (e) {
      joystickActive = false;
      resetJoystick();
      cancelAnimationFrame(joystickTimer);
      playerNextDirection = { x: 0, y: 0 };
    });
    // –ö–Ω–æ–ø–∫–∞ A (—Å—Ç—Ä–µ–ª—å–±–∞)
    abtnA.addEventListener('touchstart', e => {
      e.preventDefault();
      if (abtnA.classList.contains('active')) shootBullet();
    });
    abtnA.addEventListener('mousedown', e => {
      e.preventDefault();
      if (abtnA.classList.contains('active')) shootBullet();
    });
  </script>
</body>

</html>